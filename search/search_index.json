{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An image loading library for Android backed by Kotlin Coroutines. Coil is: Fast : Coil performs a number of optimizations including memory and disk caching, downsampling the image in memory, automatically pausing/cancelling requests, and more. Lightweight : Coil adds ~2000 methods to your APK (for apps that already use OkHttp and Coroutines), which is comparable to Picasso and significantly less than Glide and Fresco. Easy to use : Coil's API leverages Kotlin's language features for simplicity and minimal boilerplate. Modern : Coil is Kotlin-first and uses modern libraries including Coroutines, OkHttp, Okio, and AndroidX Lifecycles. Coil is an acronym for: Co routine I mage L oader. Made with \u2764\ufe0f at Instacart . Translations: \ud55c\uad6d\uc5b4 , \u4e2d\u6587 , T\u00fcrk\u00e7e Download \u00b6 Coil is available on mavenCentral() . implementation ( \"io.coil-kt:coil:2.2.2\" ) Quick Start \u00b6 ImageViews \u00b6 To load an image into an ImageView , use the load extension function: // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests can be configured with an optional trailing lambda: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } Jetpack Compose \u00b6 Import the Jetpack Compose extension library: implementation ( \"io.coil-kt:coil-compose:2.2.2\" ) To load an image, use the AsyncImage composable: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null ) Image Loaders \u00b6 Both imageView.load and AsyncImage use the singleton ImageLoader to execute image requests. The singleton ImageLoader can be accessed using a Context extension function: val imageLoader = context . imageLoader ImageLoader s are designed to be shareable and are most efficient when you create a single instance and share it throughout your app. That said, you can also create your own ImageLoader instance(s): val imageLoader = ImageLoader ( context ) If you do not want the singleton ImageLoader , depend on io.coil-kt:coil-base instead of io.coil-kt:coil . Requests \u00b6 To load an image into a custom target, enqueue an ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () val disposable = imageLoader . enqueue ( request ) To load an image imperatively, execute an ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable Requirements \u00b6 Min SDK 21+ Java 8+ R8 / Proguard \u00b6 Coil is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for Coroutines , OkHttp and Okio . License \u00b6 Copyright 2022 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#download","text":"Coil is available on mavenCentral() . implementation ( \"io.coil-kt:coil:2.2.2\" )","title":"Download"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#imageviews","text":"To load an image into an ImageView , use the load extension function: // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests can be configured with an optional trailing lambda: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) }","title":"ImageViews"},{"location":"#jetpack-compose","text":"Import the Jetpack Compose extension library: implementation ( \"io.coil-kt:coil-compose:2.2.2\" ) To load an image, use the AsyncImage composable: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null )","title":"Jetpack Compose"},{"location":"#image-loaders","text":"Both imageView.load and AsyncImage use the singleton ImageLoader to execute image requests. The singleton ImageLoader can be accessed using a Context extension function: val imageLoader = context . imageLoader ImageLoader s are designed to be shareable and are most efficient when you create a single instance and share it throughout your app. That said, you can also create your own ImageLoader instance(s): val imageLoader = ImageLoader ( context ) If you do not want the singleton ImageLoader , depend on io.coil-kt:coil-base instead of io.coil-kt:coil .","title":"Image Loaders"},{"location":"#requests","text":"To load an image into a custom target, enqueue an ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () val disposable = imageLoader . enqueue ( request ) To load an image imperatively, execute an ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable","title":"Requests"},{"location":"#requirements","text":"Min SDK 21+ Java 8+","title":"Requirements"},{"location":"#r8-proguard","text":"Coil is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for Coroutines , OkHttp and Okio .","title":"R8 / Proguard"},{"location":"#license","text":"Copyright 2022 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"README-ko/","text":"Coil\uc740 Kotlin Coroutines\uc73c\ub85c \ub9cc\ub4e4\uc5b4\uc9c4 Android \ubc31\uc564\ub4dc \uc774\ubbf8\uc9c0 \ub85c\ub529 \ub77c\uc774\ube0c\ub7ec\ub9ac\uc785\ub2c8\ub2e4. Coil \uc740: \ube60\ub974\ub2e4 : Coil\uc740 \uba54\ubaa8\ub9ac\uc640 \ub514\uc2a4\ud06c\uc758 \uce90\uc2f1, \uba54\ubaa8\ub9ac\uc758 \uc774\ubbf8\uc9c0 \ub2e4\uc6b4 \uc0d8\ud50c\ub9c1, Bitmap \uc7ac\uc0ac\uc6a9, \uc77c\uc2dc\uc815\uc9c0/\ucde8\uc18c\uc758 \uc790\ub3d9\ud654 \ub4f1\ub4f1 \uc218 \ub9ce\uc740 \ucd5c\uc801\ud654 \uc791\uc5c5\uc744 \uc218\ud589\ud569\ub2c8\ub2e4. \uac00\ubccd\ub2e4 : Coil\uc740 \ucd5c\ub300 2000\uac1c\uc758 method\ub4e4\uc744 APK\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4(\uc774\ubbf8 OkHttp\uc640 Coroutines\uc744 \uc0ac\uc6a9\uc911\uc778 \uc571\uc5d0 \ud55c\ud558\uc5ec), \uc774\ub294 Picasso \ube44\uc2b7\ud55c \uc218\uc900\uc774\uba70 Glide\uc640 Fresco\ubcf4\ub2e4\ub294 \uc801\uc2b5\ub2c8\ub2e4. \uc0ac\uc6a9\ud558\uae30 \uc27d\ub2e4 : Coil API\ub294 \uc2ec\ud50c\ud568\uacfc \ucd5c\uc18c\ud55c\uc758 boilerplate\ub97c \uc704\ud558\uc5ec Kotlin\uc758 \uae30\ub2a5\uc744 \ud65c\uc6a9\ud569\ub2c8\ub2e4. \ud604\ub300\uc801\uc774\ub2e4 : Coil\uc740 Kotlin \uc6b0\uc120\uc774\uba70 Coroutines, OkHttp, Okio, AndroidX Lifecycles\ub4f1\uc758 \ucd5c\uc2e0 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. Coil\uc740: Co routine I mage L oader\uc758 \uc57d\uc790\uc785\ub2c8\ub2e4. \u2764\ufe0f Instacart \uc5d0\uc11c \u2764\ufe0f\uc73c\ub85c \ub9cc\ub4e4\uc5c8\uc2b5\ub2c8\ub2e4. \ub2e4\uc6b4\ub85c\ub4dc \u00b6 Coil\uc740 mavenCentral() \ub85c \uc774\uc6a9 \uac00\ub2a5\ud569\ub2c8\ub2e4. implementation ( \"io.coil-kt:coil:2.2.2\" ) \ube60\ub978 \uc2dc\uc791 \u00b6 ImageViews \u00b6 ImageView \ub85c \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\uae30 \uc704\ud574, load \ud655\uc7a5 \ud568\uc218\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests\ub294 trailing lambda \uc2dd\uc744 \uc774\uc6a9\ud558\uc5ec \ucd94\uac00 \uc124\uc815\uc744 \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } Jetpack Compose \u00b6 Jetpack Compose \ud655\uc7a5 \ub77c\uc774\ube0c\ub7ec\ub9ac \ucd94\uac00: implementation ( \"io.coil-kt:coil-compose:2.2.2\" ) \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\ub824\uba74, AsyncImage composable\ub97c \uc0ac\uc6a9\ud558\uc138\uc694: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null ) Image Loaders \u00b6 imageView.load \uc640 AsyncImage \ub294 \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\uae30 \uc704\ud574 \uc2f1\uae00\ud1a4 ImageLoader \ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. \uc2f1\uae00\ud1a4 ImageLoader \ub294 Context \uc758 \ud655\uc7a5\ud568\uc218\ub97c \ud1b5\ud574 \uc811\uadfc\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4: val imageLoader = context . imageLoader ImageLoader \ub294 \uacf5\uc720\uac00 \uac00\ub2a5\ud558\uac8c \uc124\uacc4 \ub418\uc5c8\uc73c\uba70, \uc2f1\uae00 \uac1d\uccb4\ub97c \ub9cc\ub4e4\uc5b4\uc11c \uc571\uc5d0 \uc804\ubc18\uc801\uc73c\ub85c \uc0ac\uc6a9\ud588\uc744 \ub54c \uac00\uc7a5 \ud6a8\uc728\uc801\uc785\ub2c8\ub2e4. \uc989, \uc9c1\uc811 ImageLoader \uc778\uc2a4\ud134\uc2a4\ub97c \uc0dd\uc131\ud574\ub3c4 \ub429\ub2c8\ub2e4: val imageLoader = ImageLoader ( context ) \uc2f1\uae00\ud1a4 ImageLoader \ub97c \uc0ac\uc6a9\ud558\uace0 \uc2f6\uc9c0 \uc54a\uc744\ub54c\uc5d0\ub294, io.coil-kt:coil \ub97c \ucc38\uc870\ud558\ub294 \ub300\uc2e0, io.coil-kt:coil-base \ub97c \ucc38\uc870\ud558\uc138\uc694. Requests \u00b6 \ucee4\uc2a4\ud140 \ud0c0\uac9f\uc5d0 \uc774\ubbf8\uc9c0\ub97c \ub85c\ub4dc\ud558\ub824\uba74, ImageRequest \ub97c enqueue \ud558\uc138\uc694: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () val disposable = imageLoader . enqueue ( request ) Imperative\ud558\uac8c \uc774\ubbf8\uc9c0 \ub85c\ub4dc\ub97c \ud558\ub824\uba74, ImageRequest \ub97c execute \ud558\uc138\uc694: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable \uc5ec\uae30\uc11c Coil\uc758 \uc804\uccb4 \ubb38\uc11c \ub97c \ud655\uc778\ud558\uc138\uc694. \uc694\uad6c\uc0ac\ud56d \u00b6 Min SDK 21+ Java 8+ R8 / Proguard \u00b6 Coil\uc740 \ubcc4\ub3c4\uc758 \uc124\uc815 \uc5c6\uc774 R8\uacfc \uc644\ubcbd\ud558\uac8c \ud638\ud658 \uac00\ub2a5\ud558\uba70 \ucd94\uac00 \uaddc\uce59\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. Proguard\ub97c \uc0ac\uc6a9\ud560 \uacbd\uc6b0, Coroutines , OkHttp , Okio \uc5d0 \uaddc\uce59\uc744 \ucd94\uac00\ud560 \ud544\uc694\uac00 \uc788\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \ub77c\uc774\uc120\uc2a4 \u00b6 Copyright 2022 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"README ko"},{"location":"README-ko/#_1","text":"Coil\uc740 mavenCentral() \ub85c \uc774\uc6a9 \uac00\ub2a5\ud569\ub2c8\ub2e4. implementation ( \"io.coil-kt:coil:2.2.2\" )","title":"\ub2e4\uc6b4\ub85c\ub4dc"},{"location":"README-ko/#_2","text":"","title":"\ube60\ub978 \uc2dc\uc791"},{"location":"README-ko/#imageviews","text":"ImageView \ub85c \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\uae30 \uc704\ud574, load \ud655\uc7a5 \ud568\uc218\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests\ub294 trailing lambda \uc2dd\uc744 \uc774\uc6a9\ud558\uc5ec \ucd94\uac00 \uc124\uc815\uc744 \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) }","title":"ImageViews"},{"location":"README-ko/#jetpack-compose","text":"Jetpack Compose \ud655\uc7a5 \ub77c\uc774\ube0c\ub7ec\ub9ac \ucd94\uac00: implementation ( \"io.coil-kt:coil-compose:2.2.2\" ) \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\ub824\uba74, AsyncImage composable\ub97c \uc0ac\uc6a9\ud558\uc138\uc694: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null )","title":"Jetpack Compose"},{"location":"README-ko/#image-loaders","text":"imageView.load \uc640 AsyncImage \ub294 \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\uae30 \uc704\ud574 \uc2f1\uae00\ud1a4 ImageLoader \ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. \uc2f1\uae00\ud1a4 ImageLoader \ub294 Context \uc758 \ud655\uc7a5\ud568\uc218\ub97c \ud1b5\ud574 \uc811\uadfc\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4: val imageLoader = context . imageLoader ImageLoader \ub294 \uacf5\uc720\uac00 \uac00\ub2a5\ud558\uac8c \uc124\uacc4 \ub418\uc5c8\uc73c\uba70, \uc2f1\uae00 \uac1d\uccb4\ub97c \ub9cc\ub4e4\uc5b4\uc11c \uc571\uc5d0 \uc804\ubc18\uc801\uc73c\ub85c \uc0ac\uc6a9\ud588\uc744 \ub54c \uac00\uc7a5 \ud6a8\uc728\uc801\uc785\ub2c8\ub2e4. \uc989, \uc9c1\uc811 ImageLoader \uc778\uc2a4\ud134\uc2a4\ub97c \uc0dd\uc131\ud574\ub3c4 \ub429\ub2c8\ub2e4: val imageLoader = ImageLoader ( context ) \uc2f1\uae00\ud1a4 ImageLoader \ub97c \uc0ac\uc6a9\ud558\uace0 \uc2f6\uc9c0 \uc54a\uc744\ub54c\uc5d0\ub294, io.coil-kt:coil \ub97c \ucc38\uc870\ud558\ub294 \ub300\uc2e0, io.coil-kt:coil-base \ub97c \ucc38\uc870\ud558\uc138\uc694.","title":"Image Loaders"},{"location":"README-ko/#requests","text":"\ucee4\uc2a4\ud140 \ud0c0\uac9f\uc5d0 \uc774\ubbf8\uc9c0\ub97c \ub85c\ub4dc\ud558\ub824\uba74, ImageRequest \ub97c enqueue \ud558\uc138\uc694: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () val disposable = imageLoader . enqueue ( request ) Imperative\ud558\uac8c \uc774\ubbf8\uc9c0 \ub85c\ub4dc\ub97c \ud558\ub824\uba74, ImageRequest \ub97c execute \ud558\uc138\uc694: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable \uc5ec\uae30\uc11c Coil\uc758 \uc804\uccb4 \ubb38\uc11c \ub97c \ud655\uc778\ud558\uc138\uc694.","title":"Requests"},{"location":"README-ko/#_3","text":"Min SDK 21+ Java 8+","title":"\uc694\uad6c\uc0ac\ud56d"},{"location":"README-ko/#r8-proguard","text":"Coil\uc740 \ubcc4\ub3c4\uc758 \uc124\uc815 \uc5c6\uc774 R8\uacfc \uc644\ubcbd\ud558\uac8c \ud638\ud658 \uac00\ub2a5\ud558\uba70 \ucd94\uac00 \uaddc\uce59\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. Proguard\ub97c \uc0ac\uc6a9\ud560 \uacbd\uc6b0, Coroutines , OkHttp , Okio \uc5d0 \uaddc\uce59\uc744 \ucd94\uac00\ud560 \ud544\uc694\uac00 \uc788\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4.","title":"R8 / Proguard"},{"location":"README-ko/#_4","text":"Copyright 2022 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"\ub77c\uc774\uc120\uc2a4"},{"location":"README-tr/","text":"Android i\u00e7in Kotlin Coroutines taraf\u0131ndan desteklenen bir g\u00f6r\u00fcnt\u00fc y\u00fckleme k\u00fct\u00fcphanesi. Coil: H\u0131zl\u0131d\u0131r : Coil bellek ve disk \u00f6nbellekleme, bellekteki g\u00f6r\u00fcnt\u00fcy\u00fc alt-\u00f6rnekleme, bite\u015flemlerin tekrar kullan\u0131m\u0131, isteklerin otomatik olarak durdurulmas\u0131/iptali ve daha fazlas\u0131n\u0131 i\u00e7eren pek \u00e7ok say\u0131da optimizasyon ger\u00e7ekle\u015ftirir. Hafiftir : Coil, APK'n\u0131za Picasso ile benzer ve Glide ve Fresco'dan \u00f6nemli \u00f6l\u00e7\u00fcde daha az say\u0131da, 2000 civar\u0131nda metod ekler.(Halihaz\u0131rda OkHttp ve Coroutines kullanan uygulamalar i\u00e7in) Kullan\u0131m\u0131 kolayd\u0131r : Coil'in API'si basitlik ve mininum basmakal\u0131p i\u00e7in Kotlin'in dil \u00f6zelliklerini sonuna kadar kullan\u0131r. Moderndir : Coil Kotlin-\u00f6nceliklidir ve Coroutines, OkHttp, Okio ve AndroidX Lifecycles gibi modern k\u00fct\u00fcphaneleri kullan\u0131r. Coil \u015funlar\u0131n ba\u015f harflerinden olu\u015fur: Co routine I mage L oader. Instacart 'da \u2764\ufe0f ile yap\u0131ld\u0131. \u00c7eviriler: Korece , \u00c7ince Y\u00fckleme \u00b6 Coil mavenCentral() 'da mevcuttur. implementation ( \"io.coil-kt:coil:2.2.2\" ) H\u0131zl\u0131 Ba\u015flang\u0131\u00e7 \u00b6 G\u00f6r\u00fcnt\u00fcy\u00fc ImageView 'e y\u00fcklemek i\u00e7in load uzant\u0131 fonksiyonunu kullan\u0131n: // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // Ve daha fazlas\u0131... \u0130stekler tercihe ba\u011fl\u0131 bir takip eden lambda ile yap\u0131land\u0131r\u0131labilir: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } G\u00f6r\u00fcnt\u00fc Y\u00fckleyiciler \u00b6 imageView.load bir ImageRequest 'i kuyru\u011fa eklemek i\u00e7in yegane ImageLoader kullan\u0131r. Yegane ImageLoader uzant\u0131 fonksiyonu kullan\u0131larak eri\u015filebilir: val imageLoader = context . imageLoader \u0130ste\u011fe ba\u011fl\u0131 olarak, kendi ImageLoader kopya(lar\u0131)n\u0131z\u0131 olu\u015fturabilir ve ba\u011f\u0131ml\u0131l\u0131k enjeksiyonu ile enjekte edebilirsiniz: val imageLoader = ImageLoader ( context ) E\u011fer yegane ImageLoader istemiyorsan\u0131z, io.coil-kt:coil-base 'e ba\u011fl\u0131 kalabilirsiniz. \u0130stekler \u00b6 Bir g\u00f6r\u00fcnt\u00fcy\u00fc \u00f6zel bir hedefe y\u00fcklemek i\u00e7in, bir ImageRequest 'i enqueue edin: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Sonucu i\u015fleyin. } . build () val disposable = imageLoader . enqueue ( request ) Bir g\u00f6r\u00fcnt\u00fcy\u00fc mecburi bir \u015fekilde y\u00fcklemek i\u00e7in, bir ImageRequest 'i execute edin: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable Coil'in dok\u00fcmantasyonunun tamam\u0131na buradan ula\u015fabilirsiniz. Gereksinimler \u00b6 Min SDK 21+ Java 8+ R8 / Proguard \u00b6 Coil R8 ile tamamen uyumludur ve ek kurallar eklemeyi gerektirmez. E\u011fer Proguard kullan\u0131yorsan\u0131z, Coroutines , OkHttp ve Okio i\u00e7in kurallar eklemeniz gerekebilir. Lisans \u00b6 Copyright 2022 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"README tr"},{"location":"README-tr/#yukleme","text":"Coil mavenCentral() 'da mevcuttur. implementation ( \"io.coil-kt:coil:2.2.2\" )","title":"Y\u00fckleme"},{"location":"README-tr/#hzl-baslangc","text":"G\u00f6r\u00fcnt\u00fcy\u00fc ImageView 'e y\u00fcklemek i\u00e7in load uzant\u0131 fonksiyonunu kullan\u0131n: // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // Ve daha fazlas\u0131... \u0130stekler tercihe ba\u011fl\u0131 bir takip eden lambda ile yap\u0131land\u0131r\u0131labilir: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) }","title":"H\u0131zl\u0131 Ba\u015flang\u0131\u00e7"},{"location":"README-tr/#goruntu-yukleyiciler","text":"imageView.load bir ImageRequest 'i kuyru\u011fa eklemek i\u00e7in yegane ImageLoader kullan\u0131r. Yegane ImageLoader uzant\u0131 fonksiyonu kullan\u0131larak eri\u015filebilir: val imageLoader = context . imageLoader \u0130ste\u011fe ba\u011fl\u0131 olarak, kendi ImageLoader kopya(lar\u0131)n\u0131z\u0131 olu\u015fturabilir ve ba\u011f\u0131ml\u0131l\u0131k enjeksiyonu ile enjekte edebilirsiniz: val imageLoader = ImageLoader ( context ) E\u011fer yegane ImageLoader istemiyorsan\u0131z, io.coil-kt:coil-base 'e ba\u011fl\u0131 kalabilirsiniz.","title":"G\u00f6r\u00fcnt\u00fc Y\u00fckleyiciler"},{"location":"README-tr/#istekler","text":"Bir g\u00f6r\u00fcnt\u00fcy\u00fc \u00f6zel bir hedefe y\u00fcklemek i\u00e7in, bir ImageRequest 'i enqueue edin: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Sonucu i\u015fleyin. } . build () val disposable = imageLoader . enqueue ( request ) Bir g\u00f6r\u00fcnt\u00fcy\u00fc mecburi bir \u015fekilde y\u00fcklemek i\u00e7in, bir ImageRequest 'i execute edin: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable Coil'in dok\u00fcmantasyonunun tamam\u0131na buradan ula\u015fabilirsiniz.","title":"\u0130stekler"},{"location":"README-tr/#gereksinimler","text":"Min SDK 21+ Java 8+","title":"Gereksinimler"},{"location":"README-tr/#r8-proguard","text":"Coil R8 ile tamamen uyumludur ve ek kurallar eklemeyi gerektirmez. E\u011fer Proguard kullan\u0131yorsan\u0131z, Coroutines , OkHttp ve Okio i\u00e7in kurallar eklemeniz gerekebilir.","title":"R8 / Proguard"},{"location":"README-tr/#lisans","text":"Copyright 2022 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Lisans"},{"location":"README-zh/","text":"Coil \u662f\u4e00\u4e2a Android \u56fe\u7247\u52a0\u8f7d\u5e93\uff0c\u901a\u8fc7 Kotlin \u534f\u7a0b\u7684\u65b9\u5f0f\u52a0\u8f7d\u56fe\u7247\u3002\u7279\u70b9\u5982\u4e0b\uff1a \u66f4\u5feb : Coil \u5728\u6027\u80fd\u4e0a\u6709\u5f88\u591a\u4f18\u5316\uff0c\u5305\u62ec\u5185\u5b58\u7f13\u5b58\u548c\u78c1\u76d8\u7f13\u5b58\uff0c\u628a\u7f29\u7565\u56fe\u5b58\u4fdd\u5b58\u5728\u5185\u5b58\u4e2d\uff0c\u5faa\u73af\u5229\u7528 bitmap\uff0c\u81ea\u52a8\u6682\u505c\u548c\u53d6\u6d88\u56fe\u7247\u7f51\u7edc\u8bf7\u6c42\u7b49\u3002 \u66f4\u8f7b\u91cf\u7ea7 : Coil \u53ea\u67092000\u4e2a\u65b9\u6cd5\uff08\u524d\u63d0\u662f\u4f60\u7684 APP \u91cc\u9762\u96c6\u6210\u4e86 OkHttp \u548c Coroutines\uff09\uff0cCoil \u548c Picasso \u7684\u65b9\u6cd5\u6570\u5dee\u4e0d\u591a\uff0c\u76f8\u6bd4 Glide \u548c Fresco \u8981\u8f7b\u91cf\u5f88\u591a\u3002 \u66f4\u5bb9\u6613\u4f7f\u7528 : Coil \u7684 API \u5145\u5206\u5229\u7528\u4e86 Kotlin \u8bed\u8a00\u7684\u65b0\u7279\u6027\uff0c\u7b80\u5316\u548c\u51cf\u5c11\u4e86\u5f88\u591a\u6837\u677f\u4ee3\u7801\u3002 \u66f4\u6d41\u884c : Coil \u9996\u9009 Kotlin \u8bed\u8a00\u5f00\u53d1\u5e76\u4e14\u4f7f\u7528\u5305\u542b Coroutines, OkHttp, Okio \u548c AndroidX Lifecycles \u5728\u5185\u6700\u6d41\u884c\u7684\u5f00\u6e90\u5e93\u3002 Coil \u540d\u5b57\u7684\u7531\u6765\uff1a\u53d6 Co routine I mage L oader \u9996\u5b57\u6bcd\u5f97\u6765\u3002 \u5728 Instacart \u7528\u2764\ufe0f\u6253\u9020\u3002 \u4e0b\u8f7d \u00b6 Coil \u53ef\u4ee5\u5728 mavenCentral() \u4e0b\u8f7d implementation ( \"io.coil-kt:coil:2.2.2\" ) \u5feb\u901f\u4e0a\u624b \u00b6 \u53ef\u4ee5\u4f7f\u7528 ImageView \u7684\u6269\u5c55\u51fd\u6570 load \u52a0\u8f7d\u4e00\u5f20\u56fe\u7247\uff1a // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... \u53ef\u4ee5\u4f7f\u7528 lambda \u8bed\u6cd5\u8f7b\u677e\u914d\u7f6e\u8bf7\u6c42\u9009\u9879\uff1a imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } Jetpack Compose \u00b6 \u5f15\u5165 Jetpack Compose \u6269\u5c55\u5e93: implementation ( \"io.coil-kt:coil-compose:2.2.2\" ) \u4f7f\u7528 AsyncImage \u52a0\u8f7d\u56fe\u7247: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null ) \u56fe\u7247\u52a0\u8f7d\u5668 ImageLoader \u00b6 imageView.load \u4f7f\u7528\u5355\u4f8b ImageLoader \u6765\u628a ImageRequest \u52a0\u5165\u961f\u5217. ImageLoader \u5355\u4f8b\u53ef\u4ee5\u901a\u8fc7\u6269\u5c55\u65b9\u6cd5\u6765\u83b7\u53d6\uff1a val imageLoader = context . imageLoader \u6b64\u5916\uff0c\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u521b\u5efa ImageLoader \u5b9e\u4f8b\u4ece\u800c\u5b9e\u73b0\u4f9d\u8d56\u6ce8\u5165\uff1a val imageLoader = ImageLoader ( context ) \u5982\u679c\u4f60\u4e0d\u9700\u8981 ImageLoader \u4f5c\u4e3a\u5355\u4f8b\uff0c\u8bf7\u628aGradle\u4f9d\u8d56\u66ff\u6362\u6210 io.coil-kt:coil-base . \u56fe\u7247\u8bf7\u6c42 ImageRequest \u00b6 \u5982\u679c\u60f3\u5b9a\u5236 ImageRequest \u7684\u52a0\u8f7d\u76ee\u6807\uff0c\u53ef\u4ee5\u4f9d\u7167\u5982\u4e0b\u65b9\u5f0f\u628a ImageRequest \u52a0\u5165\u961f\u5217\uff1a val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () val disposable = imageLoader . enqueue ( request ) \u5982\u679c\u60f3\u547d\u4ee4\u5f0f\u5730\u6267\u884c\u56fe\u7247\u52a0\u8f7d\uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528 execute(ImageRequest) \uff1a val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable \u8bf7\u81f3 Coil \u7684 \u5b8c\u6574\u6587\u6863 \u83b7\u5f97\u66f4\u591a\u4fe1\u606f\u3002 \u73af\u5883\u8981\u6c42 \u00b6 Min SDK 21+ Java 8+ R8 / Proguard \u00b6 Coil \u517c\u5bb9 R8 \u6df7\u6dc6\uff0c\u60a8\u65e0\u9700\u518d\u6dfb\u52a0\u5176\u4ed6\u7684\u89c4\u5219 \u5982\u679c\u60a8\u9700\u8981\u6df7\u6dc6\u4ee3\u7801\uff0c\u53ef\u80fd\u9700\u8981\u6dfb\u52a0\u5bf9\u5e94\u7684\u6df7\u6dc6\u89c4\u5219\uff1a Coroutines , OkHttp , Okio \u3002 License \u00b6 Copyright 2022 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"README zh"},{"location":"README-zh/#_1","text":"Coil \u53ef\u4ee5\u5728 mavenCentral() \u4e0b\u8f7d implementation ( \"io.coil-kt:coil:2.2.2\" )","title":"\u4e0b\u8f7d"},{"location":"README-zh/#_2","text":"\u53ef\u4ee5\u4f7f\u7528 ImageView \u7684\u6269\u5c55\u51fd\u6570 load \u52a0\u8f7d\u4e00\u5f20\u56fe\u7247\uff1a // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... \u53ef\u4ee5\u4f7f\u7528 lambda \u8bed\u6cd5\u8f7b\u677e\u914d\u7f6e\u8bf7\u6c42\u9009\u9879\uff1a imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) }","title":"\u5feb\u901f\u4e0a\u624b"},{"location":"README-zh/#jetpack-compose","text":"\u5f15\u5165 Jetpack Compose \u6269\u5c55\u5e93: implementation ( \"io.coil-kt:coil-compose:2.2.2\" ) \u4f7f\u7528 AsyncImage \u52a0\u8f7d\u56fe\u7247: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null )","title":"Jetpack Compose"},{"location":"README-zh/#imageloader","text":"imageView.load \u4f7f\u7528\u5355\u4f8b ImageLoader \u6765\u628a ImageRequest \u52a0\u5165\u961f\u5217. ImageLoader \u5355\u4f8b\u53ef\u4ee5\u901a\u8fc7\u6269\u5c55\u65b9\u6cd5\u6765\u83b7\u53d6\uff1a val imageLoader = context . imageLoader \u6b64\u5916\uff0c\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u521b\u5efa ImageLoader \u5b9e\u4f8b\u4ece\u800c\u5b9e\u73b0\u4f9d\u8d56\u6ce8\u5165\uff1a val imageLoader = ImageLoader ( context ) \u5982\u679c\u4f60\u4e0d\u9700\u8981 ImageLoader \u4f5c\u4e3a\u5355\u4f8b\uff0c\u8bf7\u628aGradle\u4f9d\u8d56\u66ff\u6362\u6210 io.coil-kt:coil-base .","title":"\u56fe\u7247\u52a0\u8f7d\u5668 ImageLoader"},{"location":"README-zh/#imagerequest","text":"\u5982\u679c\u60f3\u5b9a\u5236 ImageRequest \u7684\u52a0\u8f7d\u76ee\u6807\uff0c\u53ef\u4ee5\u4f9d\u7167\u5982\u4e0b\u65b9\u5f0f\u628a ImageRequest \u52a0\u5165\u961f\u5217\uff1a val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () val disposable = imageLoader . enqueue ( request ) \u5982\u679c\u60f3\u547d\u4ee4\u5f0f\u5730\u6267\u884c\u56fe\u7247\u52a0\u8f7d\uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528 execute(ImageRequest) \uff1a val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable \u8bf7\u81f3 Coil \u7684 \u5b8c\u6574\u6587\u6863 \u83b7\u5f97\u66f4\u591a\u4fe1\u606f\u3002","title":"\u56fe\u7247\u8bf7\u6c42 ImageRequest"},{"location":"README-zh/#_3","text":"Min SDK 21+ Java 8+","title":"\u73af\u5883\u8981\u6c42"},{"location":"README-zh/#r8-proguard","text":"Coil \u517c\u5bb9 R8 \u6df7\u6dc6\uff0c\u60a8\u65e0\u9700\u518d\u6dfb\u52a0\u5176\u4ed6\u7684\u89c4\u5219 \u5982\u679c\u60a8\u9700\u8981\u6df7\u6dc6\u4ee3\u7801\uff0c\u53ef\u80fd\u9700\u8981\u6dfb\u52a0\u5bf9\u5e94\u7684\u6df7\u6dc6\u89c4\u5219\uff1a Coroutines , OkHttp , Okio \u3002","title":"R8 / Proguard"},{"location":"README-zh/#license","text":"Copyright 2022 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 [2.2.2] - October 1, 2022 \u00b6 Ensure an image loader is fully initialized before registering its system callbacks. #1465 Set the preferred bitmap config in VideoFrameDecoder on API 30+ to avoid banding. #1487 Fix parsing paths containing # in FileUriMapper . #1466 Fix reading responses with non-ascii headers from the disk cache. #1468 Fix decoding videos inside asset subfolders. #1489 Update androidx.annotation to 1.5.0. [2.2.1] - September 8, 2022 \u00b6 Fix: RoundedCornersTransformation now properly scales the input bitmap. Remove dependency on the kotlin-parcelize plugin. Update compile SDK to 33. Downgrade androidx.appcompat:appcompat-resources to 1.4.2 to work around #1423 . [2.2.0] - August 16, 2022 \u00b6 New : Add ImageRequest.videoFramePercent to coil-video to support specifying the video frame as a percent of the video's duration. New : Add ExifOrientationPolicy to configure how BitmapFactoryDecoder treats EXIF orientation data. Fix: Don't throw an exception in RoundedCornersTransformation if passed a size with an undefined dimension. Fix: Read a GIF's frame delay as two unsigned bytes instead of one signed byte. Update Kotlin to 1.7.10. Update Coroutines to 1.6.4. Update Compose to 1.2.1. Update OkHttp to 4.10.0. Update Okio to 3.2.0. Update accompanist-drawablepainter to 0.25.1. Update androidx.annotation to 1.4.0. Update androidx.appcompat:appcompat-resources to 1.5.0. Update androidx.core to 1.8.0. [2.1.0] - May 17, 2022 \u00b6 New : Support loading ByteArray s. ( #1202 ) New : Support setting custom CSS rules for SVGs using ImageRequest.Builder.css . ( #1210 ) Fix: Convert GenericViewTarget 's private methods to protected. ( #1273 ) Update compile SDK to 32. ( #1268 ) [2.0.0] - May 10, 2022 \u00b6 Coil 2.0.0 is a major iteration of the library and includes breaking changes. Check out the upgrade guide for how to upgrade. New : Introduce AsyncImage in coil-compose . Check out the documentation for more info. // Display an image from the network. AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null ) // Display an image from the network with a placeholder, circle crop, and crossfade animation. AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), placeholder = painterResource ( R . drawable . placeholder ), contentDescription = stringResource ( R . string . description ), contentScale = ContentScale . Crop , modifier = Modifier . clip ( CircleShape ) ) New : Introduce a public DiskCache API. Use ImageLoader.Builder.diskCache and DiskCache.Builder to configure the disk cache. You should not use OkHttp's Cache with Coil 2.0. See here for more info. Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. Existing disk caches will be cleared when upgrading to 2.0. The minimum supported API is now 21. ImageRequest 's default Scale is now Scale.FIT . This was changed to make ImageRequest.scale consistent with other classes that have a default Scale . Requests with an ImageViewTarget still have their Scale auto-detected. Rework the image pipeline classes: Mapper , Fetcher , and Decoder have been refactored to be more flexible. Fetcher.key has been replaced with a new Keyer interface. Keyer creates the cache key from the input data. Add ImageSource , which allows Decoder s to read File s directly using Okio's file system API. Rework the Jetpack Compose integration: rememberImagePainter and ImagePainter have been renamed to rememberAsyncImagePainter and AsyncImagePainter respectively. Deprecate LocalImageLoader . Check out the deprecation message for more info. Disable generating runtime not-null assertions. If you use Java, passing null as a not-null annotated argument to a function will no longer throw a NullPointerException immediately. Kotlin's compile-time null safety guards against this happening. This change allows the library's size to be smaller. Size is now composed of two Dimension values for its width and height. Dimension can either be a positive pixel value or Dimension.Undefined . See here for more info. BitmapPool and PoolableViewTarget have been removed from the library. VideoFrameFileFetcher and VideoFrameUriFetcher have been removed from the library. Use VideoFrameDecoder instead, which supports all data sources. BlurTransformation and GrayscaleTransformation are removed from the library. If you use them, you can copy their code into your project. Change Transition.transition to be a non-suspending function as it's no longer needed to suspend the transition until it completes. Add support for bitmapFactoryMaxParallelism , which restricts the maximum number of in-progress BitmapFactory operations. This value is 4 by default, which improves UI performance. Add support for interceptorDispatcher , fetcherDispatcher , decoderDispatcher , and transformationDispatcher . Add GenericViewTarget , which handles common ViewTarget logic. Add ByteBuffer to the default supported data types. Disposable has been refactored and exposes the underlying ImageRequest 's job. Rework the MemoryCache API. ImageRequest.error is now set on the Target if ImageRequest.fallback is null. Transformation.key is replaced with Transformation.cacheKey . Update Kotlin to 1.6.10. Update Compose to 1.1.1. Update OkHttp to 4.9.3. Update Okio to 3.0.0. Changes from 2.0.0-rc03 : - Convert Dimension.Original to be Dimension.Undefined . - This changes the semantics of the non-pixel dimension slightly to fix some edge cases ( example ) in the size system. - Load images with Size.ORIGINAL if ContentScale is None. - Fix applying ImageView.load builder argument first instead of last. - Fix not combining HTTP headers if response is not modified. [2.0.0-rc03] - April 11, 2022 \u00b6 Remove the ScaleResolver interface. Convert Size constructors to functions. Change Dimension.Pixels 's toString to only be its pixel value. Guard against a rare crash in SystemCallbacks.onTrimMemory . Update Coroutines to 1.6.1. [2.0.0-rc02] - March 20, 2022 \u00b6 Revert ImageRequest 's default size to be the size of the current display instead of Size.ORIGINAL . Fix DiskCache.Builder being marked as experimental. Only DiskCache 's methods are experimental. Fix case where loading an image into an ImageView with one dimension as WRAP_CONTENT would load the image at its original size instead of fitting it into the bounded dimension. Remove component functions from MemoryCache.Key , MemoryCache.Value , and Parameters.Entry . [2.0.0-rc01] - March 2, 2022 \u00b6 Significant changes since 1.4.0 : The minimum supported API is now 21. Rework the Jetpack Compose integration. rememberImagePainter has been renamed to rememberAsyncImagePainter . Add support for AsyncImage and SubcomposeAsyncImage . Check out the documentation for more info. Deprecate LocalImageLoader . Check out the deprecation message for more info. Coil 2.0 has its own disk cache implementation and no longer relies on OkHttp for disk caching. Use ImageLoader.Builder.diskCache and DiskCache.Builder to configure the disk cache. You should not use OkHttp's Cache with Coil 2.0 as the cache can be corrupted if a thread is interrupted while writing to it. Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. Existing disk caches will be cleared when upgrading to 2.0. ImageRequest 's default Scale is now Scale.FIT . This was changed to make ImageRequest.scale consistent with other classes that have a default Scale . Requests with an ImageViewTarget still have their Scale auto-detected. ImageRequest 's default size is now Size.ORIGINAL . Rework the image pipeline classes: Mapper , Fetcher , and Decoder have been refactored to be more flexible. Fetcher.key has been replaced with a new Keyer interface. Keyer creates the cache key from the input data. Add ImageSource , which allows Decoder s to read File s directly using Okio's file system API. Disable generating runtime not-null assertions. If you use Java, passing null as a not-null annotated parameter to a function will no longer throw a NullPointerException immediately. Kotlin's compile-time null safety guards against this happening. This change allows the library's size to be smaller. Size is now composed of two Dimension values for its width and height. Dimension can either be a positive pixel value or Dimension.Original . BitmapPool and PoolableViewTarget have been removed from the library. VideoFrameFileFetcher and VideoFrameUriFetcher are removed from the library. Use VideoFrameDecoder instead, which supports all data sources. BlurTransformation and GrayscaleTransformation are removed from the library. If you use them, you can copy their code into your project. Change Transition.transition to be a non-suspending function as it's no longer needed to suspend the transition until it completes. Add support for bitmapFactoryMaxParallelism , which restricts the maximum number of in-progress BitmapFactory operations. This value is 4 by default, which improves UI performance. Add support for interceptorDispatcher , fetcherDispatcher , decoderDispatcher , and transformationDispatcher . Add GenericViewTarget , which handles common ViewTarget logic. Add ByteBuffer to the default supported data types. Disposable has been refactored and exposes the underlying ImageRequest 's job. Rework the MemoryCache API. ImageRequest.error is now set on the Target if ImageRequest.fallback is null. Transformation.key is replaced with Transformation.cacheKey . Update Kotlin to 1.6.10. Update Compose to 1.1.1. Update OkHttp to 4.9.3. Update Okio to 3.0.0. Changes since 2.0.0-alpha09 : Remove the -Xjvm-default=all compiler flag. Fix failing to load image if multiple requests with must-revalidate/e-tag are executed concurrently. Fix DecodeUtils.isSvg returning false if there is a new line character after the <svg tag. Make LocalImageLoader.provides deprecation message clearer. Update Compose to 1.1.1. Update accompanist-drawablepainter to 0.23.1. [2.0.0-alpha09] - February 16, 2022 \u00b6 Fix AsyncImage creating invalid constraints. ( #1134 ) Add ContentScale argument to AsyncImagePainter . ( #1144 ) This should be set to the same value that's set on Image to ensure that the image is loaded at the correct size. Add ScaleResolver to support lazily resolving the Scale for an ImageRequest . ( #1134 ) ImageRequest.scale should be replaced by ImageRequest.scaleResolver.scale() . Update Compose to 1.1.0. Update accompanist-drawablepainter to 0.23.0. Update androidx.lifecycle to 2.4.1. [2.0.0-alpha08] - February 7, 2022 \u00b6 Update DiskCache and ImageSource to use to Okio's FileSystem API. ( #1115 ) [2.0.0-alpha07] - January 30, 2022 \u00b6 Significantly improve AsyncImage performance and split AsyncImage into AsyncImage and SubcomposeAsyncImage . ( #1048 ) SubcomposeAsyncImage provides loading / success / error / content slot APIs and uses subcomposition which has worse performance. AsyncImage provides placeholder / error / fallback arguments to overwrite the Painter that's drawn when loading or if the request is unsuccessful. AsyncImage does not use subcomposition and has much better performance than SubcomposeAsyncImage . Remove AsyncImagePainter.State argument from SubcomposeAsyncImage.content . Use painter.state if needed. Add onLoading / onSuccess / onError callbacks to both AsyncImage and SubcomposeAsyncImage . Deprecate LocalImageLoader . ( #1101 ) Add support for ImageRequest.tags . ( #1066 ) Move isGif , isWebP , isAnimatedWebP , isHeif , and isAnimatedHeif in DecodeUtils into coil-gif. Add isSvg to coil-svg. ( #1117 ) Convert FetchResult and DecodeResult to be non-data classes. ( #1114 ) Remove unused DiskCache.Builder context argument. ( #1099 ) Fix scaling for bitmap resources with original size. ( #1072 ) Fix failing to close ImageDecoder in ImageDecoderDecoder . ( #1109 ) Fix incorrect scaling when converting a drawable to a bitmap. ( #1084 ) Update Compose to 1.1.0-rc03. Update accompanist-drawablepainter to 0.22.1-rc. Update androidx.appcompat:appcompat-resources to 1.4.1. [2.0.0-alpha06] - December 24, 2021 \u00b6 Add ImageSource.Metadata to support decoding from assets, resources, and content URIs without buffering or temporary files. ( #1060 ) Delay executing the image request until AsyncImage has positive constraints. ( #1028 ) Fix using DefaultContent for AsyncImage if loading , success , and error are all set. ( #1026 ) Use androidx LruCache instead of the platform LruCache . ( #1047 ) Update Kotlin to 1.6.10. Update Coroutines to 1.6.0. Update Compose to 1.1.0-rc01. Update accompanist-drawablepainter to 0.22.0-rc. Update androidx.collection to 1.2.0. [2.0.0-alpha05] - November 28, 2021 \u00b6 Important : Refactor Size to support using the image's original size for either dimension. Size is now composed of two Dimension values for its width and height. Dimension can either be a positive pixel value or Dimension.Original . This change was made to better support unbounded width/height values (e.g. wrap_content , Constraints.Infinity ) when one dimension is a fixed pixel value. Fix: Support inspection mode (preview) for AsyncImage . Fix: SuccessResult.memoryCacheKey should always be null if imageLoader.memoryCache is null. Convert ImageLoader , SizeResolver , and ViewSizeResolver constructor-like invoke functions to top level functions. Make CrossfadeDrawable start and end drawables public API. Mutate ImageLoader placeholder/error/fallback drawables. Add default arguments to SuccessResult 's constructor. Depend on androidx.collection instead of androidx.collection-ktx . Update OkHttp to 4.9.3. [2.0.0-alpha04] - November 22, 2021 \u00b6 New : Add AsyncImage to coil-compose . AsyncImage is a composable that executes an ImageRequest asynchronously and renders the result. AsyncImage is intended to replace rememberImagePainter for most use cases. Its API is not final and may change before the final 2.0 release. It has a similar API to Image and supports the same arguments: Alignment , ContentScale , alpha , ColorFilter , and FilterQuality . It supports overwriting what's drawn for each AsyncImagePainter state using the content , loading , success , and error arguments. It fixes a number of design issues that rememberImagePainter has with resolving image size and scale. Example usages: // Only draw the image. AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null // Avoid `null` and set this to a localized string if possible. ) // Draw the image with a circle crop, crossfade, and overwrite the `loading` state. AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), contentDescription = null , modifier = Modifier . clip ( CircleShape ), loading = { CircularProgressIndicator () }, contentScale = ContentScale . Crop ) // Draw the image with a circle crop, crossfade, and overwrite all states. AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), contentDescription = null , modifier = Modifier . clip ( CircleShape ), contentScale = ContentScale . Crop ) { state -> if ( state is AsyncImagePainter . State . Loading ) { CircularProgressIndicator () } else { AsyncImageContent () // Draws the image. } } Important : Rename ImagePainter to AsyncImagePainter and rememberImagePainter to rememberAsyncImagePainter . ExecuteCallback is no longer supported. To have the AsyncImagePainter skip waiting for onDraw to be called, set ImageRequest.size(OriginalSize) (or any size) instead. Add an optional FilterQuality argument to rememberAsyncImagePainter . Use coroutines for cleanup operations in DiskCache and add DiskCache.Builder.cleanupDispatcher . Fix Compose preview for placeholder set using ImageLoader.Builder.placeholder . Mark LocalImageLoader.current with @ReadOnlyComposable to generate more efficient code. Update Compose to 1.1.0-beta03 and depend on compose.foundation instead of compose.ui . Update androidx.appcompat-resources to 1.4.0. [2.0.0-alpha03] - November 12, 2021 \u00b6 Add ability to load music thumbnails on Android 29+. ( #967 ) Fix: Use context.resources to load resources for current package. ( #968 ) Fix: clear -> dispose replacement expression. ( #970 ) Update Compose to 1.0.5. Update accompanist-drawablepainter to 0.20.2. Update Okio to 3.0.0. Update androidx.annotation to 1.3.0. Update androidx.core to 1.7.0. Update androidx.lifecycle to 2.4.0. Remove dependency on lifecycle-common-java8 as it's been merged into lifecycle-common . [2.0.0-alpha02] - October 24, 2021 \u00b6 Add a new coil-bom artifact which includes a bill of materials . Importing coil-bom allows you to depend on other Coil artifacts without specifying a version. Fix failing to load an image when using ExecuteCallback.Immediate . Update Okio to 3.0.0-alpha.11. This also resolves a compatibility issue with Okio 3.0.0-alpha.11. Update Kotlin to 1.5.31. Update Compose to 1.0.4. [2.0.0-alpha01] - October 11, 2021 \u00b6 Coil 2.0.0 is the next major iteration of the library and has new features, performance improvements, API improvements, and various bug fixes. This release may be binary/source incompatible with future alpha releases until the stable release of 2.0.0. Important : The minimum supported API is now 21. Important : Enable -Xjvm-default=all . This generates Java 8 default methods instead of using Kotlin's default interface method support. Check out this blog post for more information. You'll need to add -Xjvm-default=all or -Xjvm-default=all-compatibility to your build file as well. See here for how to do this. Important : Coil now has its own disk cache implementation and no longer relies on OkHttp for disk caching. This change was made to: Better support thread interruption while decoding images. This improves performance when image requests are started and stopped in quick succession. Support exposing ImageSource s backed by File s. This avoids unnecessary copying when an Android API requires a File to decode (e.g. MediaMetadataRetriever ). Support reading from/writing to the disk cache files directly. Use ImageLoader.Builder.diskCache and DiskCache.Builder to configure the disk cache. You should not use OkHttp's Cache with Coil 2.0 as it can be corrupted if it's interrupted while writing to it. Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. Support for cache headers can be enabled or disabled using ImageLoader.Builder.respectCacheHeaders . Your existing disk cache will be cleared and rebuilt when upgrading to 2.0. Important : ImageRequest 's default Scale is now Scale.FIT This was changed to make ImageRequest.scale consistent with other classes that have a default Scale . Requests with an ImageViewTarget still have their scale autodetected. Significant changes to the image pipeline classes: Mapper , Fetcher , and Decoder have been refactored to be more flexible. Fetcher.key has been replaced with a new Keyer interface. Keyer creates the cache key from the input data. Adds ImageSource , which allows Decoder s to decode File s directly. BitmapPool and PoolableViewTarget have been removed from the library. Bitmap pooling was removed because: It's most effective on <= API 23 and has become less effective with newer Android releases. Removing bitmap pooling allows Coil to use immutable bitmaps, which have performance benefits. There's runtime overhead to manage the bitmap pool. Bitmap pooling creates design restrictions on Coil's API as it requires tracking if a bitmap is eligible for pooling. Removing bitmap pooling allows Coil to expose the result Drawable in more places (e.g. Listener , Disposable ). Additionally, this means Coil doesn't have to clear ImageView s, which has can cause issues . Bitmap pooling is error-prone . Allocating a new bitmap is much safer than attempting to re-use a bitmap that could still be in use. MemoryCache has been refactored to be more flexible. Disable generating runtime not-null assertions. If you use Java, passing null as a not-null annotated parameter to a function will no longer throw a NullPointerException immediately. If you use Kotlin, there is essentially no change. This change allows the library's size to be smaller. VideoFrameFileFetcher and VideoFrameUriFetcher are removed from the library. Use VideoFrameDecoder instead, which supports all data sources. Adds support for bitmapFactoryMaxParallelism , which restricts the maximum number of in-progress BitmapFactory operations. This value is 4 by default, which improves UI performance. Adds support for interceptorDispatcher , fetcherDispatcher , decoderDispatcher , and transformationDispatcher . Disposable has been refactored and exposes the underlying ImageRequest 's job. Change Transition.transition to be a non-suspending function as it's no longer needed to suspend the transition until it completes. Add GenericViewTarget , which handles common ViewTarget logic. BlurTransformation and GrayscaleTransformation are removed from the library. If you use them, you can copy their code into your project. ImageRequest.error is now set on the Target if ImageRequest.fallback is null. Transformation.key is replaced with Transformation.cacheKey . ImageRequest.Listener returns SuccessResult / ErrorResult in onSuccess and onError respectively. Add ByteBuffer s to the default supported data types. Remove toString implementations from several classes. Update OkHttp to 4.9.2. Update Okio to 3.0.0-alpha.10. [1.4.0] - October 6, 2021 \u00b6 New : Add ImageResult to ImagePainter.State.Success and ImagePainter.State.Error . ( #887 ) This is a binary incompatible change to the signatures of ImagePainter.State.Success and ImagePainter.State.Error , however these APIs are marked as experimental. Only execute CrossfadeTransition if View.isShown is true . Previously it would only check View.isVisible . ( #898 ) Fix potential memory cache miss if scaling multiplier is slightly less than 1 due to a rounding issue. ( #899 ) Make non-inlined ComponentRegistry methods public. ( #925 ) Depend on accompanist-drawablepainter and remove Coil's custom DrawablePainter implementation. ( #845 ) Remove use of a Java 8 method to guard against desugaring issue. ( #924 ) Promote ImagePainter.ExecuteCallback to stable API. ( #927 ) Update compileSdk to 31. Update Kotlin to 1.5.30. Update Coroutines to 1.5.2. Update Compose to 1.0.3. [1.3.2] - August 4, 2021 \u00b6 coil-compose now depends on compose.ui instead of compose.foundation . compose.ui is a smaller dependency as it's a subset of compose.foundation . Update Jetpack Compose to 1.0.1. Update Kotlin to 1.5.21. Update Coroutines to 1.5.1. Update androidx.exifinterface:exifinterface to 1.3.3. [1.3.1] - July 28, 2021 \u00b6 Update Jetpack Compose to 1.0.0 . Huge congrats to the Compose team on the stable release ! Update androidx.appcompat:appcompat-resources to 1.3.1. [1.3.0] - July 10, 2021 \u00b6 New : Add support for Jetpack Compose . It's based on Accompanist 's Coil integration, but has a number of changes. Check out the docs for more info. Add allowConversionToBitmap to enable/disable the automatic bitmap conversion for Transformation s. ( #775 ) Add enforceMinimumFrameDelay to ImageDecoderDecoder and GifDecoder to enable rewriting a GIF's frame delay if it's below a threshold. ( #783 ) This is disabled by default, but will be enabled by default in a future release. Add support for enabling/disabling an ImageLoader 's internal network observer. ( #741 ) Fix the density of bitmaps decoded by BitmapFactoryDecoder . ( #776 ) Fix Licensee not finding Coil's licence url. ( #774 ) Update androidx.core:core-ktx to 1.6.0. [1.2.2] - June 4, 2021 \u00b6 Fix race condition while converting a drawable with shared state to a bitmap. ( #771 ) Fix ImageLoader.Builder.fallback setting the error drawable instead of the fallback drawable. Fix incorrect data source returned by ResourceUriFetcher . ( #770 ) Fix log check for no available file descriptors on API 26 and 27. Fix incorrect version check for platform vector drawable support. ( #751 ) Update Kotlin (1.5.10). Update Coroutines (1.5.0). Update androidx.appcompat:appcompat-resources to 1.3.0. Update androidx.core:core-ktx to 1.5.0. [1.2.1] - April 27, 2021 \u00b6 Fix VideoFrameUriFetcher attempting to handle http/https URIs. ( #734 [1.2.0] - April 12, 2021 \u00b6 Important : Use an SVG's view bounds to calculate its aspect ratio in SvgDecoder . ( #688 ) Previously, SvgDecoder used an SVG's width / height elements to determine its aspect ratio, however this doesn't correctly follow the SVG specification. To revert to the old behaviour set useViewBoundsAsIntrinsicSize = false when constructing your SvgDecoder . New : Add VideoFrameDecoder to support decoding video frames from any source. ( #689 ) New : Support automatic SVG detection using the source's contents instead of just the MIME type. ( #654 ) New : Support sharing resources using ImageLoader.newBuilder() . ( #653 ) Importantly, this enables sharing memory caches between ImageLoader instances. New : Add support for animated image transformations using AnimatedTransformation . ( #659 ) New : Add support for start/end callbacks for animated drawables. ( #676 ) Fix parsing EXIF data for HEIF/HEIC files. ( #664 ) Fix not using the EmptyBitmapPool implementation if bitmap pooling is disabled. ( #638 ) Without this fix bitmap pooling was still disabled properly, however it used a more heavyweight BitmapPool implementation. Fix case where MovieDrawable.getOpacity would incorrectly return transparent. ( #682 ) Guard against the default temporary directory not existing. ( #683 ) Build using the JVM IR backend. ( #670 ) Update Kotlin (1.4.32). Update Coroutines (1.4.3). Update OkHttp (3.12.13). Update androidx.lifecycle:lifecycle-common-java8 to 2.3.1. [1.1.1] - January 11, 2021 \u00b6 Fix a case where ViewSizeResolver.size could throw an IllegalStateException due to resuming a coroutine more than once. Fix HttpFetcher blocking forever if called from the main thread. Requests that are forced to execute on the main thread using ImageRequest.dispatcher(Dispatchers.Main.immediate) will fail with a NetworkOnMainThreadException unless ImageRequest.networkCachePolicy is set to CachePolicy.DISABLED or CachePolicy.WRITE_ONLY . Rotate video frames from VideoFrameFetcher if the video has rotation metadata. Update Kotlin (1.4.21). Update Coroutines (1.4.2). Update Okio (2.10.0). Update androidx.exifinterface:exifinterface (1.3.2). [1.1.0] - November 24, 2020 \u00b6 Important : Change the CENTER and MATRIX ImageView scale types to resolve to OriginalSize . ( #587 ) This change only affects the implicit size resolution algorithm when the request's size isn't specified explicitly. This change was made to ensure that the visual result of an image request is consistent with ImageView.setImageResource / ImageView.setImageURI . To revert to the old behaviour set a ViewSizeResolver when constructing your request. Important : Return the display size from ViewSizeResolver if the view's layout param is WRAP_CONTENT . ( #562 ) Previously, we would only return the display size if the view has been fully laid out. This change makes the typical behaviour more consistent and intuitive. Add the ability to control alpha pre-multiplication. ( #569 ) Support preferring exact intrinsic size in CrossfadeDrawable . ( #585 ) Check for the full GIF header including version. ( #564 ) Add an empty bitmap pool implementation. ( #561 ) Make EventListener.Factory a functional interface. ( #575 ) Stabilize EventListener . ( #574 ) Add String overload for ImageRequest.Builder.placeholderMemoryCacheKey . Add @JvmOverloads to the ViewSizeResolver constructor. Fix: Mutate start/end drawables in CrossfadeDrawable . ( #572 ) Fix: Fix GIF not playing on second load. ( #577 ) Update Kotlin (1.4.20) and migrate to the kotlin-parcelize plugin. Update Coroutines (1.4.1). [1.0.0] - October 22, 2020 \u00b6 Changes since 0.13.0 : - Add Context.imageLoader extension function. ( #534 ) - Add ImageLoader.executeBlocking extension function. ( #537 ) - Don't shutdown previous singleton image loader if replaced. ( #533 ) Changes since 1.0.0-rc3 : - Fix: Guard against missing/invalid ActivityManager. ( #541 ) - Fix: Allow OkHttp to cache unsuccessful responses. ( #551 ) - Update Kotlin to 1.4.10. - Update Okio to 2.9.0. - Update androidx.exifinterface:exifinterface to 1.3.1. [1.0.0-rc3] - September 21, 2020 \u00b6 Revert using the -Xjvm-default=all compiler flag due to instability. This is a source compatible, but binary incompatible change from previous release candidate versions. Add Context.imageLoader extension function. ( #534 ) Add ImageLoader.executeBlocking extension function. ( #537 ) Don't shutdown previous singleton image loader if replaced. ( #533 ) Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.3.0 [1.0.0-rc2] - September 3, 2020 \u00b6 This release requires Kotlin 1.4.0 or above. All the changes present in 0.13.0 . Depend on the base Kotlin stdlib instead of stdlib-jdk8 . [0.13.0] - September 3, 2020 \u00b6 Important : Launch the Interceptor chain on the main thread by default. ( #513 ) This largely restores the behaviour from 0.11.0 and below where the memory cache would be checked synchronously on the main thread. To revert to using the same behaviour as 0.12.0 where the memory cache is checked on ImageRequest.dispatcher , set ImageLoader.Builder.launchInterceptorChainOnMainThread(false) . See launchInterceptorChainOnMainThread for more information. Fix: Fix potential memory leak if request is started on a ViewTarget in a detached fragment. ( #518 ) Fix: Use ImageRequest.context to load resource URIs. ( #517 ) Fix: Fix race condition that could cause subsequent requests to not be saved to the disk cache. ( #510 ) Fix: Use blockCountLong and blockSizeLong on API 18. Make ImageLoaderFactory a fun interface. Add ImageLoader.Builder.addLastModifiedToFileCacheKey which allows you to enable/disable adding the last modified timestamp to the memory cache key for an image loaded from a File . Update Kotlin to 1.4.0. Update Coroutines to 1.3.9. Update Okio to 2.8.0. [1.0.0-rc1] - August 18, 2020 \u00b6 This release requires Kotlin 1.4.0 or above. Update Kotlin to 1.4.0 and enable -Xjvm-default=all . See here for how to enable -Xjvm-default=all in your build file. This generates Java 8 default methods for default Kotlin interface methods. Remove all existing deprecated methods in 0.12.0. Update Coroutines to 1.3.9. [0.12.0] - August 18, 2020 \u00b6 Breaking : LoadRequest and GetRequest have been replaced with ImageRequest : ImageLoader.execute(LoadRequest) -> ImageLoader.enqueue(ImageRequest) ImageLoader.execute(GetRequest) -> ImageLoader.execute(ImageRequest) ImageRequest implements equals / hashCode . Breaking : A number of classes were renamed and/or changed package: coil.request.RequestResult -> coil.request.ImageResult coil.request.RequestDisposable -> coil.request.Disposable coil.bitmappool.BitmapPool -> coil.bitmap.BitmapPool coil.DefaultRequestOptions -> coil.request.DefaultRequestOptions Breaking : SparseIntArraySet has been removed from the public API. Breaking : TransitionTarget no longer implements ViewTarget . Breaking : ImageRequest.Listener.onSuccess 's signature has changed to return an ImageResult.Metadata instead of just a DataSource . Breaking : Remove support for LoadRequest.aliasKeys . This API is better handled with direct read/write access to the memory cache. Important : Values in the memory cache are no longer resolved synchronously (if called from the main thread). This change was also necessary to support executing Interceptor s on a background dispatcher. This change also moves more work off the main thread, improving performance. Important : Mappers are now executed on a background dispatcher. As a side effect, automatic bitmap sampling is no longer automatically supported. To achieve the same effect, use the MemoryCache.Key of a previous request as the placeholderMemoryCacheKey of the subsequent request. See here for an example . The placeholderMemoryCacheKey API offers more freedom as you can \"link\" two image requests with different data (e.g. different URLs for small/large images). Important : Coil's ImageView extension functions have been moved from the coil.api package to the coil package. Use find + replace to refactor import coil.api.load -> import coil.load . Unfortunately, it's not possible to use Kotlin's ReplaceWith functionality to replace imports. Important : Use standard crossfade if drawables are not the same image. Important : Prefer immutable bitmaps on API 24+. Important : MeasuredMapper has been deprecated in favour of the new Interceptor interface. See here for an example of how to convert a MeasuredMapper into an Interceptor . Interceptor is a much less restrictive API that allows for a wider range of custom logic. Important : ImageRequest.data is now not null. If you create an ImageRequest without setting its data it will return NullRequestData as its data. New : Add support for direct read/write access to an ImageLoader 's MemoryCache . See the docs for more information. New : Add support for Interceptor s. See the docs for more information. Coil's Interceptor design is heavily inspired by OkHttp 's! New : Add the ability to enable/disable bitmap pooling using ImageLoader.Builder.bitmapPoolingEnabled . Bitmap pooling is most effective on API 23 and below, but may still be benificial on API 24 and up (by eagerly calling Bitmap.recycle ). New : Support thread interruption while decoding. Fix parsing multiple segments in content-type header. Rework bitmap reference counting to be more robust. Fix WebP decoding on API < 19 devices. Expose FetchResult and DecodeResult in the EventListener API. Compile with SDK 30. Update Coroutines to 1.3.8. Update OkHttp to 3.12.12. Update Okio to 2.7.0. Update AndroidX dependencies: androidx.appcompat:appcompat-resources -> 1.2.0 androidx.core:core-ktx -> 1.3.1 [0.11.0] - May 14, 2020 \u00b6 Breaking : This version removes all existing deprecated functions. This enables removing Coil's ContentProvider so it doesn't run any code at app startup. Breaking : Convert SparseIntArraySet.size to a val. ( #380 ) Breaking : Move Parameters.count() to an extension function. ( #403 ) Breaking : Make BitmapPool.maxSize an Int. ( #404 ) Important : Make ImageLoader.shutdown() optional (similar to OkHttpClient ). ( #385 ) Fix: Fix AGP 4.1 compatibility. ( #386 ) Fix: Fix measuring GONE views. ( #397 ) Reduce the default memory cache size to 20%. ( #390 ) To restore the existing behaviour set ImageLoaderBuilder.availableMemoryPercentage(0.25) when creating your ImageLoader . Update Coroutines to 1.3.6. Update OkHttp to 3.12.11. [0.10.1] - April 26, 2020 \u00b6 Fix OOM when decoding large PNGs on API 23 and below. ( #372 ). This disables decoding EXIF orientation for PNG files. PNG EXIF orientation is very rarely used and reading PNG EXIF data (even if it's empty) requires buffering the entire file into memory, which is bad for performance. Minor Java compatibility improvements to SparseIntArraySet . Update Okio to 2.6.0. [0.10.0] - April 20, 2020 \u00b6 Highlights \u00b6 This version deprecates most of the DSL API in favour of using the builders directly. Here's what the change looks like: // 0.9.5 (old) val imageLoader = ImageLoader ( context ) { bitmapPoolPercentage ( 0.5 ) crossfade ( true ) } val disposable = imageLoader . load ( context , \"https://www.example.com/image.jpg\" ) { target ( imageView ) } val drawable = imageLoader . get ( \"https://www.example.com/image.jpg\" ) { size ( 512 , 512 ) } // 0.10.0 (new) val imageLoader = ImageLoader . Builder ( context ) . bitmapPoolPercentage ( 0.5 ) . crossfade ( true ) . build () val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . execute ( request ) val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 512 , 512 ) . build () val drawable = imageLoader . execute ( request ). drawable If you're using the io.coil-kt:coil artifact, you can call Coil.execute(request) to execute the request with the singleton ImageLoader . ImageLoader s now have a weak reference memory cache that tracks weak references to images once they're evicted from the strong reference memory cache. This means an image will always be returned from an ImageLoader 's memory cache if there's still a strong reference to it. Generally, this should make the memory cache much more predictable and increase its hit rate. This behaviour can be enabled/disabled with ImageLoaderBuilder.trackWeakReferences . Add a new artifact, io.coil-kt:coil-video , to decode specific frames from a video file. Read more here . Add a new EventListener API for tracking metrics. Add ImageLoaderFactory which can be implemented by your Application to simplify singleton initialization. Full Release Notes \u00b6 Important : Deprecate DSL syntax in favour of builder syntax. ( #267 ) Important : Deprecate Coil and ImageLoader extension functions. ( #322 ) Breaking : Return sealed RequestResult type from ImageLoader.execute(GetRequest) . ( #349 ) Breaking : Rename ExperimentalCoil to ExperimentalCoilApi . Migrate from @Experimental to @RequiresOptIn . ( #306 ) Breaking : Replace CoilLogger with Logger interface. ( #316 ) Breaking : Rename destWidth/destHeight to dstWidth/dstHeight. ( #275 ) Breaking : Re-arrange MovieDrawable 's constructor params. ( #272 ) Breaking : Request.Listener 's methods now receive the full Request object instead of just its data. Breaking : GetRequestBuilder now requires a Context in its constructor. Breaking : Several properties on Request are now nullable. Behaviour change : Include parameter values in the cache key by default. ( #319 ) Behaviour change : Slightly adjust Request.Listener.onStart() timing to be called immediately after Target.onStart() . ( #348 ) New : Add WeakMemoryCache implementation. ( #295 ) New : Add coil-video to support decoding video frames. ( #122 ) New : Introduce EventListener . ( #314 ) New : Introduce ImageLoaderFactory . ( #311 ) New : Support animated HEIF image sequences on Android 11. ( #297 ) New : Improve Java compatibility. ( #262 ) New : Support setting a default CachePolicy . ( #307 ) New : Support setting a default Bitmap.Config . ( #342 ) New : Add ImageLoader.invalidate(key) to clear a single memory cache item ( #55 ) New : Add debug logs to explain why a cached image is not reused. ( #346 ) New : Support error and fallback drawables for get requests. Fix: Fix memory cache miss when Transformation reduces input bitmap's size. ( #357 ) Fix: Ensure radius is below RenderScript max in BlurTransformation. ( #291 ) Fix: Fix decoding high colour depth images. ( #358 ) Fix: Disable ImageDecoderDecoder crash work-around on Android 11 and above. ( #298 ) Fix: Fix failing to read EXIF data on pre-API 23. ( #331 ) Fix: Fix incompatibility with Android R SDK. ( #337 ) Fix: Only enable inexact size if ImageView has a matching SizeResolver . ( #344 ) Fix: Allow cached images to be at most one pixel off requested size. ( #360 ) Fix: Skip crossfade transition if view is not visible. ( #361 ) Deprecate CoilContentProvider . ( #293 ) Annotate several ImageLoader methods with @MainThread . Avoid creating a LifecycleCoroutineDispatcher if the lifecycle is currently started. ( #356 ) Use full package name for OriginalSize.toString() . Preallocate when decoding software bitmap. ( #354 ) Update Kotlin to 1.3.72. Update Coroutines to 1.3.5. Update OkHttp to 3.12.10. Update Okio to 2.5.0. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.2.0 [0.9.5] - February 6, 2020 \u00b6 Fix: Ensure a view is attached before checking if it is hardware accelerated. This fixes a case where requesting a hardware bitmap could miss the memory cache. Update AndroidX dependencies: androidx.core:core-ktx -> 1.2.0 [0.9.4] - February 3, 2020 \u00b6 Fix: Respect aspect ratio when downsampling in ImageDecoderDecoder. Thanks @zhanghai. Previously bitmaps would be returned from the memory cache as long as their config was greater than or equal to the config specified in the request. For example, if you requested an ARGB_8888 bitmap, it would be possible to have a RGBA_F16 bitmap returned to you from the memory cache. Now, the cached config and the requested config must be equal. Make scale and durationMillis public in CrossfadeDrawable and CrossfadeTransition . [0.9.3] - February 1, 2020 \u00b6 Fix: Translate child drawable inside ScaleDrawable to ensure it is centered. Fix: Fix case where GIFs and SVGs would not fill bounds completely. Defer calling HttpUrl.get() to background thread. Improve BitmapFactory null bitmap error message. Add 3 devices to hardware bitmap blacklist. ( #264 ) Update AndroidX dependencies: androidx.lifecycle:lifecycle-common-java8 -> 2.2.0 [0.9.2] - January 19, 2020 \u00b6 Fix: Fix decoding GIFs on pre-API 19. Thanks @mario. Fix: Fix rasterized vector drawables not being marked as sampled. Fix: Throw exception if Movie dimensions are <= 0. Fix: Fix CrossfadeTransition not being resumed for a memory cache event. Fix: Prevent returning hardware bitmaps to all target methods if disallowed. Fix: Fix MovieDrawable not positioning itself in the center of its bounds. Remove automatic scaling from CrossfadeDrawable. Make BitmapPool.trimMemory public. Wrap AnimatedImageDrawable in a ScaleDrawable to ensure it fills its bounds. Add @JvmOverloads to RequestBuilder.setParameter. Set an SVG's view box to its size if the view box is not set. Pass state and level changes to CrossfadeDrawable children. Update OkHttp to 3.12.8. [0.9.1] - December 30, 2019 \u00b6 Fix: Fix crash when calling LoadRequestBuilder.crossfade(false) . [0.9.0] - December 30, 2019 \u00b6 Breaking : Transformation.transform now includes a Size parameter. This is to support transformations that change the size of the output Bitmap based on the size of the Target . Requests with transformations are now also exempt from image sampling . Breaking : Transformation s are now applied to any type of Drawable . Before, Transformation s would be skipped if the input Drawable was not a BitmapDrawable . Now, Drawable s are rendered to a Bitmap before applying the Transformation s. Breaking : Passing null data to ImageLoader.load is now treated as an error and calls Target.onError and Request.Listener.onError with a NullRequestDataException . This change was made to support setting a fallback drawable if data is null . Previously the request was silently ignored. Breaking : RequestDisposable.isDisposed is now a val . New : Support for custom transitions. See here for more info . Transitions are marked as experimental as the API is incubating. New : Add RequestDisposable.await to support suspending while a LoadRequest is in progress. New : Support setting a fallback drawable when request data is null. New : Add Precision . This makes the size of the output Drawable exact while enabling scaling optimizations for targets that support scaling (e.g. ImageViewTarget ). See its documentation for more information. New : Add RequestBuilder.aliasKeys to support matching multiple cache keys. Fix: Make RequestDisposable thread safe. Fix: RoundedCornersTransformation now crops to the size of the target then rounds the corners. Fix: CircleCropTransformation now crops from the center. Fix: Add several devices to the hardware bitmap blacklist . Fix: Preserve aspect ratio when converting a Drawable to a Bitmap. Fix: Fix possible memory cache miss with Scale.FIT . Fix: Ensure Parameters iteration order is deterministic. Fix: Defensive copy when creating Parameters and ComponentRegistry. Fix: Ensure RealBitmapPool's maxSize >= 0. Fix: Show the start drawable if CrossfadeDrawable is not animating or done. Fix: Adjust CrossfadeDrawable to account for children with undefined intrinsic size. Fix: Fix MovieDrawable not scaling properly. Update Kotlin to 1.3.61. Update Kotlin Coroutines to 1.3.3. Update Okio to 2.4.3. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.1.0 [0.8.0] - October 22, 2019 \u00b6 Breaking : SvgDrawable has been removed. Instead, SVGs are now prerendered to BitmapDrawable s by SvgDecoder . This makes SVGs significantly less expensive to render on the main thread . Also SvgDecoder now requires a Context in its constructor. Breaking : SparseIntArraySet extension functions have moved to the coil.extension package. New : Support setting per-request network headers. See here for more info . New : Add new Parameters API to support passing custom data through the image pipeline. New : Support individual corner radii in RoundedCornersTransformation. Thanks @khatv911. New : Add ImageView.clear() to support proactively freeing resources. New : Support loading resources from other packages. New : Add subtractPadding attribute to ViewSizeResolver to enable/disable subtracting a view's padding when measuring. New : Improve HttpUrlFetcher MIME type detection. New : Add Animatable2Compat support to MovieDrawable and CrossfadeDrawable. New : Add RequestBuilder<*>.repeatCount to set the repeat count for a GIF. New : Add BitmapPool creation to the public API. New : Annotate Request.Listener methods with @MainThread . Fix: Make CoilContentProvider visible for testing. Fix: Include night mode in the resource cache key. Fix: Work around ImageDecoder native crash by temporarily writing the source to disk. Fix: Correctly handle contact display photo uris. Fix: Pass tint to CrossfadeDrawable's children. Fix: Fix several instances of not closing sources. Fix: Add a blacklist of devices with broken/incomplete hardware bitmap implementations. Compile against SDK 29. Update Kotlin Coroutines to 1.3.2. Update OkHttp to 3.12.6. Update Okio to 2.4.1. Change appcompat-resources from compileOnly to implementation for coil-base . [0.7.0] - September 8, 2019 \u00b6 Breaking : ImageLoaderBuilder.okHttpClient(OkHttpClient.Builder.() -> Unit) is now ImageLoaderBuilder.okHttpClient(() -> OkHttpClient) . The initializer is also now called lazily on a background thread. If you set a custom OkHttpClient you must set OkHttpClient.cache to enable disk caching. If you don't set a custom OkHttpClient , Coil will create the default OkHttpClient which has disk caching enabled. The default Coil cache can be created using CoilUtils.createDefaultCache(context) . e.g.: val imageLoader = ImageLoader ( context ) { okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } } Breaking : Fetcher.key no longer has a default implementation. Breaking : Previously, only the first applicable Mapper would be called. Now, all applicable Mapper s will be called. No API changes. Breaking : Minor named parameter renaming: url -> uri , factory -> initializer . New : coil-svg artifact, which has an SvgDecoder that supports automatically decoding SVGs. Powered by AndroidSVG . Thanks @rharter. New : load(String) and get(String) now accept any of the supported Uri schemes. e.g. You can now do imageView.load(\"file:///path/to/file.jpg\") . New : Refactor ImageLoader to use Call.Factory instead of OkHttpClient . This allows lazy initialization of the networking resources using ImageLoaderBuilder.okHttpClient { OkHttpClient() } . Thanks @ZacSweers. New : RequestBuilder.decoder to explicitly set the decoder for a request. New : ImageLoaderBuilder.allowHardware to enable/disable hardware bitmaps by default for an ImageLoader. New : Support software rendering in ImageDecoderDecoder. Fix: Multiple bugs with loading vector drawables. Fix: Support WRAP_CONTENT View dimensions. Fix: Support parsing EXIF data longer than 8192 bytes. Fix: Don't stretch drawables with different aspect ratios when crossfading. Fix: Guard against network observer failing to register due to exception. Fix: Fix divide by zero error in MovieDrawable. Thanks @R12rus. Fix: Support nested Android asset files. Thanks @JaCzekanski. Fix: Guard against running out of file descriptors on Android O and O_MR1. Fix: Don't crash when disabling memory cache. Thanks @hansenji. Fix: Ensure Target.cancel is always called from the main thread. Update Kotlin to 1.3.50. Update Kotlin Coroutines to 1.3.0. Update OkHttp to 3.12.4. Update Okio to 2.4.0. Update AndroidX dependencies to the latest stable versions: androidx.appcompat:appcompat -> 1.1.0 androidx.core:core-ktx -> 1.1.0 androidx.lifecycle:lifecycle-common-java8 -> 2.1.0 Replace appcompat with appcompat-resources as an optional compileOnly dependency. appcompat-resources is a much smaller artifact. [0.6.1] - August 16, 2019 \u00b6 New: Add transformations(List<Transformation>) to RequestBuilder. Fix: Add the last modified date to the cache key for file uris. Fix: Ensure View dimensions are evaluated to at least 1px. Fix: Clear MovieDrawable's canvas between frames. Fix: Open assets correctly. [0.6.0] - August 12, 2019 \u00b6 Initial release.","title":"Change Log"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#222-october-1-2022","text":"Ensure an image loader is fully initialized before registering its system callbacks. #1465 Set the preferred bitmap config in VideoFrameDecoder on API 30+ to avoid banding. #1487 Fix parsing paths containing # in FileUriMapper . #1466 Fix reading responses with non-ascii headers from the disk cache. #1468 Fix decoding videos inside asset subfolders. #1489 Update androidx.annotation to 1.5.0.","title":"[2.2.2] - October 1, 2022"},{"location":"changelog/#221-september-8-2022","text":"Fix: RoundedCornersTransformation now properly scales the input bitmap. Remove dependency on the kotlin-parcelize plugin. Update compile SDK to 33. Downgrade androidx.appcompat:appcompat-resources to 1.4.2 to work around #1423 .","title":"[2.2.1] - September 8, 2022"},{"location":"changelog/#220-august-16-2022","text":"New : Add ImageRequest.videoFramePercent to coil-video to support specifying the video frame as a percent of the video's duration. New : Add ExifOrientationPolicy to configure how BitmapFactoryDecoder treats EXIF orientation data. Fix: Don't throw an exception in RoundedCornersTransformation if passed a size with an undefined dimension. Fix: Read a GIF's frame delay as two unsigned bytes instead of one signed byte. Update Kotlin to 1.7.10. Update Coroutines to 1.6.4. Update Compose to 1.2.1. Update OkHttp to 4.10.0. Update Okio to 3.2.0. Update accompanist-drawablepainter to 0.25.1. Update androidx.annotation to 1.4.0. Update androidx.appcompat:appcompat-resources to 1.5.0. Update androidx.core to 1.8.0.","title":"[2.2.0] - August 16, 2022"},{"location":"changelog/#210-may-17-2022","text":"New : Support loading ByteArray s. ( #1202 ) New : Support setting custom CSS rules for SVGs using ImageRequest.Builder.css . ( #1210 ) Fix: Convert GenericViewTarget 's private methods to protected. ( #1273 ) Update compile SDK to 32. ( #1268 )","title":"[2.1.0] - May 17, 2022"},{"location":"changelog/#200-may-10-2022","text":"Coil 2.0.0 is a major iteration of the library and includes breaking changes. Check out the upgrade guide for how to upgrade. New : Introduce AsyncImage in coil-compose . Check out the documentation for more info. // Display an image from the network. AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null ) // Display an image from the network with a placeholder, circle crop, and crossfade animation. AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), placeholder = painterResource ( R . drawable . placeholder ), contentDescription = stringResource ( R . string . description ), contentScale = ContentScale . Crop , modifier = Modifier . clip ( CircleShape ) ) New : Introduce a public DiskCache API. Use ImageLoader.Builder.diskCache and DiskCache.Builder to configure the disk cache. You should not use OkHttp's Cache with Coil 2.0. See here for more info. Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. Existing disk caches will be cleared when upgrading to 2.0. The minimum supported API is now 21. ImageRequest 's default Scale is now Scale.FIT . This was changed to make ImageRequest.scale consistent with other classes that have a default Scale . Requests with an ImageViewTarget still have their Scale auto-detected. Rework the image pipeline classes: Mapper , Fetcher , and Decoder have been refactored to be more flexible. Fetcher.key has been replaced with a new Keyer interface. Keyer creates the cache key from the input data. Add ImageSource , which allows Decoder s to read File s directly using Okio's file system API. Rework the Jetpack Compose integration: rememberImagePainter and ImagePainter have been renamed to rememberAsyncImagePainter and AsyncImagePainter respectively. Deprecate LocalImageLoader . Check out the deprecation message for more info. Disable generating runtime not-null assertions. If you use Java, passing null as a not-null annotated argument to a function will no longer throw a NullPointerException immediately. Kotlin's compile-time null safety guards against this happening. This change allows the library's size to be smaller. Size is now composed of two Dimension values for its width and height. Dimension can either be a positive pixel value or Dimension.Undefined . See here for more info. BitmapPool and PoolableViewTarget have been removed from the library. VideoFrameFileFetcher and VideoFrameUriFetcher have been removed from the library. Use VideoFrameDecoder instead, which supports all data sources. BlurTransformation and GrayscaleTransformation are removed from the library. If you use them, you can copy their code into your project. Change Transition.transition to be a non-suspending function as it's no longer needed to suspend the transition until it completes. Add support for bitmapFactoryMaxParallelism , which restricts the maximum number of in-progress BitmapFactory operations. This value is 4 by default, which improves UI performance. Add support for interceptorDispatcher , fetcherDispatcher , decoderDispatcher , and transformationDispatcher . Add GenericViewTarget , which handles common ViewTarget logic. Add ByteBuffer to the default supported data types. Disposable has been refactored and exposes the underlying ImageRequest 's job. Rework the MemoryCache API. ImageRequest.error is now set on the Target if ImageRequest.fallback is null. Transformation.key is replaced with Transformation.cacheKey . Update Kotlin to 1.6.10. Update Compose to 1.1.1. Update OkHttp to 4.9.3. Update Okio to 3.0.0. Changes from 2.0.0-rc03 : - Convert Dimension.Original to be Dimension.Undefined . - This changes the semantics of the non-pixel dimension slightly to fix some edge cases ( example ) in the size system. - Load images with Size.ORIGINAL if ContentScale is None. - Fix applying ImageView.load builder argument first instead of last. - Fix not combining HTTP headers if response is not modified.","title":"[2.0.0] - May 10, 2022"},{"location":"changelog/#200-rc03-april-11-2022","text":"Remove the ScaleResolver interface. Convert Size constructors to functions. Change Dimension.Pixels 's toString to only be its pixel value. Guard against a rare crash in SystemCallbacks.onTrimMemory . Update Coroutines to 1.6.1.","title":"[2.0.0-rc03] - April 11, 2022"},{"location":"changelog/#200-rc02-march-20-2022","text":"Revert ImageRequest 's default size to be the size of the current display instead of Size.ORIGINAL . Fix DiskCache.Builder being marked as experimental. Only DiskCache 's methods are experimental. Fix case where loading an image into an ImageView with one dimension as WRAP_CONTENT would load the image at its original size instead of fitting it into the bounded dimension. Remove component functions from MemoryCache.Key , MemoryCache.Value , and Parameters.Entry .","title":"[2.0.0-rc02] - March 20, 2022"},{"location":"changelog/#200-rc01-march-2-2022","text":"Significant changes since 1.4.0 : The minimum supported API is now 21. Rework the Jetpack Compose integration. rememberImagePainter has been renamed to rememberAsyncImagePainter . Add support for AsyncImage and SubcomposeAsyncImage . Check out the documentation for more info. Deprecate LocalImageLoader . Check out the deprecation message for more info. Coil 2.0 has its own disk cache implementation and no longer relies on OkHttp for disk caching. Use ImageLoader.Builder.diskCache and DiskCache.Builder to configure the disk cache. You should not use OkHttp's Cache with Coil 2.0 as the cache can be corrupted if a thread is interrupted while writing to it. Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. Existing disk caches will be cleared when upgrading to 2.0. ImageRequest 's default Scale is now Scale.FIT . This was changed to make ImageRequest.scale consistent with other classes that have a default Scale . Requests with an ImageViewTarget still have their Scale auto-detected. ImageRequest 's default size is now Size.ORIGINAL . Rework the image pipeline classes: Mapper , Fetcher , and Decoder have been refactored to be more flexible. Fetcher.key has been replaced with a new Keyer interface. Keyer creates the cache key from the input data. Add ImageSource , which allows Decoder s to read File s directly using Okio's file system API. Disable generating runtime not-null assertions. If you use Java, passing null as a not-null annotated parameter to a function will no longer throw a NullPointerException immediately. Kotlin's compile-time null safety guards against this happening. This change allows the library's size to be smaller. Size is now composed of two Dimension values for its width and height. Dimension can either be a positive pixel value or Dimension.Original . BitmapPool and PoolableViewTarget have been removed from the library. VideoFrameFileFetcher and VideoFrameUriFetcher are removed from the library. Use VideoFrameDecoder instead, which supports all data sources. BlurTransformation and GrayscaleTransformation are removed from the library. If you use them, you can copy their code into your project. Change Transition.transition to be a non-suspending function as it's no longer needed to suspend the transition until it completes. Add support for bitmapFactoryMaxParallelism , which restricts the maximum number of in-progress BitmapFactory operations. This value is 4 by default, which improves UI performance. Add support for interceptorDispatcher , fetcherDispatcher , decoderDispatcher , and transformationDispatcher . Add GenericViewTarget , which handles common ViewTarget logic. Add ByteBuffer to the default supported data types. Disposable has been refactored and exposes the underlying ImageRequest 's job. Rework the MemoryCache API. ImageRequest.error is now set on the Target if ImageRequest.fallback is null. Transformation.key is replaced with Transformation.cacheKey . Update Kotlin to 1.6.10. Update Compose to 1.1.1. Update OkHttp to 4.9.3. Update Okio to 3.0.0. Changes since 2.0.0-alpha09 : Remove the -Xjvm-default=all compiler flag. Fix failing to load image if multiple requests with must-revalidate/e-tag are executed concurrently. Fix DecodeUtils.isSvg returning false if there is a new line character after the <svg tag. Make LocalImageLoader.provides deprecation message clearer. Update Compose to 1.1.1. Update accompanist-drawablepainter to 0.23.1.","title":"[2.0.0-rc01] - March 2, 2022"},{"location":"changelog/#200-alpha09-february-16-2022","text":"Fix AsyncImage creating invalid constraints. ( #1134 ) Add ContentScale argument to AsyncImagePainter . ( #1144 ) This should be set to the same value that's set on Image to ensure that the image is loaded at the correct size. Add ScaleResolver to support lazily resolving the Scale for an ImageRequest . ( #1134 ) ImageRequest.scale should be replaced by ImageRequest.scaleResolver.scale() . Update Compose to 1.1.0. Update accompanist-drawablepainter to 0.23.0. Update androidx.lifecycle to 2.4.1.","title":"[2.0.0-alpha09] - February 16, 2022"},{"location":"changelog/#200-alpha08-february-7-2022","text":"Update DiskCache and ImageSource to use to Okio's FileSystem API. ( #1115 )","title":"[2.0.0-alpha08] - February 7, 2022"},{"location":"changelog/#200-alpha07-january-30-2022","text":"Significantly improve AsyncImage performance and split AsyncImage into AsyncImage and SubcomposeAsyncImage . ( #1048 ) SubcomposeAsyncImage provides loading / success / error / content slot APIs and uses subcomposition which has worse performance. AsyncImage provides placeholder / error / fallback arguments to overwrite the Painter that's drawn when loading or if the request is unsuccessful. AsyncImage does not use subcomposition and has much better performance than SubcomposeAsyncImage . Remove AsyncImagePainter.State argument from SubcomposeAsyncImage.content . Use painter.state if needed. Add onLoading / onSuccess / onError callbacks to both AsyncImage and SubcomposeAsyncImage . Deprecate LocalImageLoader . ( #1101 ) Add support for ImageRequest.tags . ( #1066 ) Move isGif , isWebP , isAnimatedWebP , isHeif , and isAnimatedHeif in DecodeUtils into coil-gif. Add isSvg to coil-svg. ( #1117 ) Convert FetchResult and DecodeResult to be non-data classes. ( #1114 ) Remove unused DiskCache.Builder context argument. ( #1099 ) Fix scaling for bitmap resources with original size. ( #1072 ) Fix failing to close ImageDecoder in ImageDecoderDecoder . ( #1109 ) Fix incorrect scaling when converting a drawable to a bitmap. ( #1084 ) Update Compose to 1.1.0-rc03. Update accompanist-drawablepainter to 0.22.1-rc. Update androidx.appcompat:appcompat-resources to 1.4.1.","title":"[2.0.0-alpha07] - January 30, 2022"},{"location":"changelog/#200-alpha06-december-24-2021","text":"Add ImageSource.Metadata to support decoding from assets, resources, and content URIs without buffering or temporary files. ( #1060 ) Delay executing the image request until AsyncImage has positive constraints. ( #1028 ) Fix using DefaultContent for AsyncImage if loading , success , and error are all set. ( #1026 ) Use androidx LruCache instead of the platform LruCache . ( #1047 ) Update Kotlin to 1.6.10. Update Coroutines to 1.6.0. Update Compose to 1.1.0-rc01. Update accompanist-drawablepainter to 0.22.0-rc. Update androidx.collection to 1.2.0.","title":"[2.0.0-alpha06] - December 24, 2021"},{"location":"changelog/#200-alpha05-november-28-2021","text":"Important : Refactor Size to support using the image's original size for either dimension. Size is now composed of two Dimension values for its width and height. Dimension can either be a positive pixel value or Dimension.Original . This change was made to better support unbounded width/height values (e.g. wrap_content , Constraints.Infinity ) when one dimension is a fixed pixel value. Fix: Support inspection mode (preview) for AsyncImage . Fix: SuccessResult.memoryCacheKey should always be null if imageLoader.memoryCache is null. Convert ImageLoader , SizeResolver , and ViewSizeResolver constructor-like invoke functions to top level functions. Make CrossfadeDrawable start and end drawables public API. Mutate ImageLoader placeholder/error/fallback drawables. Add default arguments to SuccessResult 's constructor. Depend on androidx.collection instead of androidx.collection-ktx . Update OkHttp to 4.9.3.","title":"[2.0.0-alpha05] - November 28, 2021"},{"location":"changelog/#200-alpha04-november-22-2021","text":"New : Add AsyncImage to coil-compose . AsyncImage is a composable that executes an ImageRequest asynchronously and renders the result. AsyncImage is intended to replace rememberImagePainter for most use cases. Its API is not final and may change before the final 2.0 release. It has a similar API to Image and supports the same arguments: Alignment , ContentScale , alpha , ColorFilter , and FilterQuality . It supports overwriting what's drawn for each AsyncImagePainter state using the content , loading , success , and error arguments. It fixes a number of design issues that rememberImagePainter has with resolving image size and scale. Example usages: // Only draw the image. AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null // Avoid `null` and set this to a localized string if possible. ) // Draw the image with a circle crop, crossfade, and overwrite the `loading` state. AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), contentDescription = null , modifier = Modifier . clip ( CircleShape ), loading = { CircularProgressIndicator () }, contentScale = ContentScale . Crop ) // Draw the image with a circle crop, crossfade, and overwrite all states. AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), contentDescription = null , modifier = Modifier . clip ( CircleShape ), contentScale = ContentScale . Crop ) { state -> if ( state is AsyncImagePainter . State . Loading ) { CircularProgressIndicator () } else { AsyncImageContent () // Draws the image. } } Important : Rename ImagePainter to AsyncImagePainter and rememberImagePainter to rememberAsyncImagePainter . ExecuteCallback is no longer supported. To have the AsyncImagePainter skip waiting for onDraw to be called, set ImageRequest.size(OriginalSize) (or any size) instead. Add an optional FilterQuality argument to rememberAsyncImagePainter . Use coroutines for cleanup operations in DiskCache and add DiskCache.Builder.cleanupDispatcher . Fix Compose preview for placeholder set using ImageLoader.Builder.placeholder . Mark LocalImageLoader.current with @ReadOnlyComposable to generate more efficient code. Update Compose to 1.1.0-beta03 and depend on compose.foundation instead of compose.ui . Update androidx.appcompat-resources to 1.4.0.","title":"[2.0.0-alpha04] - November 22, 2021"},{"location":"changelog/#200-alpha03-november-12-2021","text":"Add ability to load music thumbnails on Android 29+. ( #967 ) Fix: Use context.resources to load resources for current package. ( #968 ) Fix: clear -> dispose replacement expression. ( #970 ) Update Compose to 1.0.5. Update accompanist-drawablepainter to 0.20.2. Update Okio to 3.0.0. Update androidx.annotation to 1.3.0. Update androidx.core to 1.7.0. Update androidx.lifecycle to 2.4.0. Remove dependency on lifecycle-common-java8 as it's been merged into lifecycle-common .","title":"[2.0.0-alpha03] - November 12, 2021"},{"location":"changelog/#200-alpha02-october-24-2021","text":"Add a new coil-bom artifact which includes a bill of materials . Importing coil-bom allows you to depend on other Coil artifacts without specifying a version. Fix failing to load an image when using ExecuteCallback.Immediate . Update Okio to 3.0.0-alpha.11. This also resolves a compatibility issue with Okio 3.0.0-alpha.11. Update Kotlin to 1.5.31. Update Compose to 1.0.4.","title":"[2.0.0-alpha02] - October 24, 2021"},{"location":"changelog/#200-alpha01-october-11-2021","text":"Coil 2.0.0 is the next major iteration of the library and has new features, performance improvements, API improvements, and various bug fixes. This release may be binary/source incompatible with future alpha releases until the stable release of 2.0.0. Important : The minimum supported API is now 21. Important : Enable -Xjvm-default=all . This generates Java 8 default methods instead of using Kotlin's default interface method support. Check out this blog post for more information. You'll need to add -Xjvm-default=all or -Xjvm-default=all-compatibility to your build file as well. See here for how to do this. Important : Coil now has its own disk cache implementation and no longer relies on OkHttp for disk caching. This change was made to: Better support thread interruption while decoding images. This improves performance when image requests are started and stopped in quick succession. Support exposing ImageSource s backed by File s. This avoids unnecessary copying when an Android API requires a File to decode (e.g. MediaMetadataRetriever ). Support reading from/writing to the disk cache files directly. Use ImageLoader.Builder.diskCache and DiskCache.Builder to configure the disk cache. You should not use OkHttp's Cache with Coil 2.0 as it can be corrupted if it's interrupted while writing to it. Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. Support for cache headers can be enabled or disabled using ImageLoader.Builder.respectCacheHeaders . Your existing disk cache will be cleared and rebuilt when upgrading to 2.0. Important : ImageRequest 's default Scale is now Scale.FIT This was changed to make ImageRequest.scale consistent with other classes that have a default Scale . Requests with an ImageViewTarget still have their scale autodetected. Significant changes to the image pipeline classes: Mapper , Fetcher , and Decoder have been refactored to be more flexible. Fetcher.key has been replaced with a new Keyer interface. Keyer creates the cache key from the input data. Adds ImageSource , which allows Decoder s to decode File s directly. BitmapPool and PoolableViewTarget have been removed from the library. Bitmap pooling was removed because: It's most effective on <= API 23 and has become less effective with newer Android releases. Removing bitmap pooling allows Coil to use immutable bitmaps, which have performance benefits. There's runtime overhead to manage the bitmap pool. Bitmap pooling creates design restrictions on Coil's API as it requires tracking if a bitmap is eligible for pooling. Removing bitmap pooling allows Coil to expose the result Drawable in more places (e.g. Listener , Disposable ). Additionally, this means Coil doesn't have to clear ImageView s, which has can cause issues . Bitmap pooling is error-prone . Allocating a new bitmap is much safer than attempting to re-use a bitmap that could still be in use. MemoryCache has been refactored to be more flexible. Disable generating runtime not-null assertions. If you use Java, passing null as a not-null annotated parameter to a function will no longer throw a NullPointerException immediately. If you use Kotlin, there is essentially no change. This change allows the library's size to be smaller. VideoFrameFileFetcher and VideoFrameUriFetcher are removed from the library. Use VideoFrameDecoder instead, which supports all data sources. Adds support for bitmapFactoryMaxParallelism , which restricts the maximum number of in-progress BitmapFactory operations. This value is 4 by default, which improves UI performance. Adds support for interceptorDispatcher , fetcherDispatcher , decoderDispatcher , and transformationDispatcher . Disposable has been refactored and exposes the underlying ImageRequest 's job. Change Transition.transition to be a non-suspending function as it's no longer needed to suspend the transition until it completes. Add GenericViewTarget , which handles common ViewTarget logic. BlurTransformation and GrayscaleTransformation are removed from the library. If you use them, you can copy their code into your project. ImageRequest.error is now set on the Target if ImageRequest.fallback is null. Transformation.key is replaced with Transformation.cacheKey . ImageRequest.Listener returns SuccessResult / ErrorResult in onSuccess and onError respectively. Add ByteBuffer s to the default supported data types. Remove toString implementations from several classes. Update OkHttp to 4.9.2. Update Okio to 3.0.0-alpha.10.","title":"[2.0.0-alpha01] - October 11, 2021"},{"location":"changelog/#140-october-6-2021","text":"New : Add ImageResult to ImagePainter.State.Success and ImagePainter.State.Error . ( #887 ) This is a binary incompatible change to the signatures of ImagePainter.State.Success and ImagePainter.State.Error , however these APIs are marked as experimental. Only execute CrossfadeTransition if View.isShown is true . Previously it would only check View.isVisible . ( #898 ) Fix potential memory cache miss if scaling multiplier is slightly less than 1 due to a rounding issue. ( #899 ) Make non-inlined ComponentRegistry methods public. ( #925 ) Depend on accompanist-drawablepainter and remove Coil's custom DrawablePainter implementation. ( #845 ) Remove use of a Java 8 method to guard against desugaring issue. ( #924 ) Promote ImagePainter.ExecuteCallback to stable API. ( #927 ) Update compileSdk to 31. Update Kotlin to 1.5.30. Update Coroutines to 1.5.2. Update Compose to 1.0.3.","title":"[1.4.0] - October 6, 2021"},{"location":"changelog/#132-august-4-2021","text":"coil-compose now depends on compose.ui instead of compose.foundation . compose.ui is a smaller dependency as it's a subset of compose.foundation . Update Jetpack Compose to 1.0.1. Update Kotlin to 1.5.21. Update Coroutines to 1.5.1. Update androidx.exifinterface:exifinterface to 1.3.3.","title":"[1.3.2] - August 4, 2021"},{"location":"changelog/#131-july-28-2021","text":"Update Jetpack Compose to 1.0.0 . Huge congrats to the Compose team on the stable release ! Update androidx.appcompat:appcompat-resources to 1.3.1.","title":"[1.3.1] - July 28, 2021"},{"location":"changelog/#130-july-10-2021","text":"New : Add support for Jetpack Compose . It's based on Accompanist 's Coil integration, but has a number of changes. Check out the docs for more info. Add allowConversionToBitmap to enable/disable the automatic bitmap conversion for Transformation s. ( #775 ) Add enforceMinimumFrameDelay to ImageDecoderDecoder and GifDecoder to enable rewriting a GIF's frame delay if it's below a threshold. ( #783 ) This is disabled by default, but will be enabled by default in a future release. Add support for enabling/disabling an ImageLoader 's internal network observer. ( #741 ) Fix the density of bitmaps decoded by BitmapFactoryDecoder . ( #776 ) Fix Licensee not finding Coil's licence url. ( #774 ) Update androidx.core:core-ktx to 1.6.0.","title":"[1.3.0] - July 10, 2021"},{"location":"changelog/#122-june-4-2021","text":"Fix race condition while converting a drawable with shared state to a bitmap. ( #771 ) Fix ImageLoader.Builder.fallback setting the error drawable instead of the fallback drawable. Fix incorrect data source returned by ResourceUriFetcher . ( #770 ) Fix log check for no available file descriptors on API 26 and 27. Fix incorrect version check for platform vector drawable support. ( #751 ) Update Kotlin (1.5.10). Update Coroutines (1.5.0). Update androidx.appcompat:appcompat-resources to 1.3.0. Update androidx.core:core-ktx to 1.5.0.","title":"[1.2.2] - June 4, 2021"},{"location":"changelog/#121-april-27-2021","text":"Fix VideoFrameUriFetcher attempting to handle http/https URIs. ( #734","title":"[1.2.1] - April 27, 2021"},{"location":"changelog/#120-april-12-2021","text":"Important : Use an SVG's view bounds to calculate its aspect ratio in SvgDecoder . ( #688 ) Previously, SvgDecoder used an SVG's width / height elements to determine its aspect ratio, however this doesn't correctly follow the SVG specification. To revert to the old behaviour set useViewBoundsAsIntrinsicSize = false when constructing your SvgDecoder . New : Add VideoFrameDecoder to support decoding video frames from any source. ( #689 ) New : Support automatic SVG detection using the source's contents instead of just the MIME type. ( #654 ) New : Support sharing resources using ImageLoader.newBuilder() . ( #653 ) Importantly, this enables sharing memory caches between ImageLoader instances. New : Add support for animated image transformations using AnimatedTransformation . ( #659 ) New : Add support for start/end callbacks for animated drawables. ( #676 ) Fix parsing EXIF data for HEIF/HEIC files. ( #664 ) Fix not using the EmptyBitmapPool implementation if bitmap pooling is disabled. ( #638 ) Without this fix bitmap pooling was still disabled properly, however it used a more heavyweight BitmapPool implementation. Fix case where MovieDrawable.getOpacity would incorrectly return transparent. ( #682 ) Guard against the default temporary directory not existing. ( #683 ) Build using the JVM IR backend. ( #670 ) Update Kotlin (1.4.32). Update Coroutines (1.4.3). Update OkHttp (3.12.13). Update androidx.lifecycle:lifecycle-common-java8 to 2.3.1.","title":"[1.2.0] - April 12, 2021"},{"location":"changelog/#111-january-11-2021","text":"Fix a case where ViewSizeResolver.size could throw an IllegalStateException due to resuming a coroutine more than once. Fix HttpFetcher blocking forever if called from the main thread. Requests that are forced to execute on the main thread using ImageRequest.dispatcher(Dispatchers.Main.immediate) will fail with a NetworkOnMainThreadException unless ImageRequest.networkCachePolicy is set to CachePolicy.DISABLED or CachePolicy.WRITE_ONLY . Rotate video frames from VideoFrameFetcher if the video has rotation metadata. Update Kotlin (1.4.21). Update Coroutines (1.4.2). Update Okio (2.10.0). Update androidx.exifinterface:exifinterface (1.3.2).","title":"[1.1.1] - January 11, 2021"},{"location":"changelog/#110-november-24-2020","text":"Important : Change the CENTER and MATRIX ImageView scale types to resolve to OriginalSize . ( #587 ) This change only affects the implicit size resolution algorithm when the request's size isn't specified explicitly. This change was made to ensure that the visual result of an image request is consistent with ImageView.setImageResource / ImageView.setImageURI . To revert to the old behaviour set a ViewSizeResolver when constructing your request. Important : Return the display size from ViewSizeResolver if the view's layout param is WRAP_CONTENT . ( #562 ) Previously, we would only return the display size if the view has been fully laid out. This change makes the typical behaviour more consistent and intuitive. Add the ability to control alpha pre-multiplication. ( #569 ) Support preferring exact intrinsic size in CrossfadeDrawable . ( #585 ) Check for the full GIF header including version. ( #564 ) Add an empty bitmap pool implementation. ( #561 ) Make EventListener.Factory a functional interface. ( #575 ) Stabilize EventListener . ( #574 ) Add String overload for ImageRequest.Builder.placeholderMemoryCacheKey . Add @JvmOverloads to the ViewSizeResolver constructor. Fix: Mutate start/end drawables in CrossfadeDrawable . ( #572 ) Fix: Fix GIF not playing on second load. ( #577 ) Update Kotlin (1.4.20) and migrate to the kotlin-parcelize plugin. Update Coroutines (1.4.1).","title":"[1.1.0] - November 24, 2020"},{"location":"changelog/#100-october-22-2020","text":"Changes since 0.13.0 : - Add Context.imageLoader extension function. ( #534 ) - Add ImageLoader.executeBlocking extension function. ( #537 ) - Don't shutdown previous singleton image loader if replaced. ( #533 ) Changes since 1.0.0-rc3 : - Fix: Guard against missing/invalid ActivityManager. ( #541 ) - Fix: Allow OkHttp to cache unsuccessful responses. ( #551 ) - Update Kotlin to 1.4.10. - Update Okio to 2.9.0. - Update androidx.exifinterface:exifinterface to 1.3.1.","title":"[1.0.0] - October 22, 2020"},{"location":"changelog/#100-rc3-september-21-2020","text":"Revert using the -Xjvm-default=all compiler flag due to instability. This is a source compatible, but binary incompatible change from previous release candidate versions. Add Context.imageLoader extension function. ( #534 ) Add ImageLoader.executeBlocking extension function. ( #537 ) Don't shutdown previous singleton image loader if replaced. ( #533 ) Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.3.0","title":"[1.0.0-rc3] - September 21, 2020"},{"location":"changelog/#100-rc2-september-3-2020","text":"This release requires Kotlin 1.4.0 or above. All the changes present in 0.13.0 . Depend on the base Kotlin stdlib instead of stdlib-jdk8 .","title":"[1.0.0-rc2] - September 3, 2020"},{"location":"changelog/#0130-september-3-2020","text":"Important : Launch the Interceptor chain on the main thread by default. ( #513 ) This largely restores the behaviour from 0.11.0 and below where the memory cache would be checked synchronously on the main thread. To revert to using the same behaviour as 0.12.0 where the memory cache is checked on ImageRequest.dispatcher , set ImageLoader.Builder.launchInterceptorChainOnMainThread(false) . See launchInterceptorChainOnMainThread for more information. Fix: Fix potential memory leak if request is started on a ViewTarget in a detached fragment. ( #518 ) Fix: Use ImageRequest.context to load resource URIs. ( #517 ) Fix: Fix race condition that could cause subsequent requests to not be saved to the disk cache. ( #510 ) Fix: Use blockCountLong and blockSizeLong on API 18. Make ImageLoaderFactory a fun interface. Add ImageLoader.Builder.addLastModifiedToFileCacheKey which allows you to enable/disable adding the last modified timestamp to the memory cache key for an image loaded from a File . Update Kotlin to 1.4.0. Update Coroutines to 1.3.9. Update Okio to 2.8.0.","title":"[0.13.0] - September 3, 2020"},{"location":"changelog/#100-rc1-august-18-2020","text":"This release requires Kotlin 1.4.0 or above. Update Kotlin to 1.4.0 and enable -Xjvm-default=all . See here for how to enable -Xjvm-default=all in your build file. This generates Java 8 default methods for default Kotlin interface methods. Remove all existing deprecated methods in 0.12.0. Update Coroutines to 1.3.9.","title":"[1.0.0-rc1] - August 18, 2020"},{"location":"changelog/#0120-august-18-2020","text":"Breaking : LoadRequest and GetRequest have been replaced with ImageRequest : ImageLoader.execute(LoadRequest) -> ImageLoader.enqueue(ImageRequest) ImageLoader.execute(GetRequest) -> ImageLoader.execute(ImageRequest) ImageRequest implements equals / hashCode . Breaking : A number of classes were renamed and/or changed package: coil.request.RequestResult -> coil.request.ImageResult coil.request.RequestDisposable -> coil.request.Disposable coil.bitmappool.BitmapPool -> coil.bitmap.BitmapPool coil.DefaultRequestOptions -> coil.request.DefaultRequestOptions Breaking : SparseIntArraySet has been removed from the public API. Breaking : TransitionTarget no longer implements ViewTarget . Breaking : ImageRequest.Listener.onSuccess 's signature has changed to return an ImageResult.Metadata instead of just a DataSource . Breaking : Remove support for LoadRequest.aliasKeys . This API is better handled with direct read/write access to the memory cache. Important : Values in the memory cache are no longer resolved synchronously (if called from the main thread). This change was also necessary to support executing Interceptor s on a background dispatcher. This change also moves more work off the main thread, improving performance. Important : Mappers are now executed on a background dispatcher. As a side effect, automatic bitmap sampling is no longer automatically supported. To achieve the same effect, use the MemoryCache.Key of a previous request as the placeholderMemoryCacheKey of the subsequent request. See here for an example . The placeholderMemoryCacheKey API offers more freedom as you can \"link\" two image requests with different data (e.g. different URLs for small/large images). Important : Coil's ImageView extension functions have been moved from the coil.api package to the coil package. Use find + replace to refactor import coil.api.load -> import coil.load . Unfortunately, it's not possible to use Kotlin's ReplaceWith functionality to replace imports. Important : Use standard crossfade if drawables are not the same image. Important : Prefer immutable bitmaps on API 24+. Important : MeasuredMapper has been deprecated in favour of the new Interceptor interface. See here for an example of how to convert a MeasuredMapper into an Interceptor . Interceptor is a much less restrictive API that allows for a wider range of custom logic. Important : ImageRequest.data is now not null. If you create an ImageRequest without setting its data it will return NullRequestData as its data. New : Add support for direct read/write access to an ImageLoader 's MemoryCache . See the docs for more information. New : Add support for Interceptor s. See the docs for more information. Coil's Interceptor design is heavily inspired by OkHttp 's! New : Add the ability to enable/disable bitmap pooling using ImageLoader.Builder.bitmapPoolingEnabled . Bitmap pooling is most effective on API 23 and below, but may still be benificial on API 24 and up (by eagerly calling Bitmap.recycle ). New : Support thread interruption while decoding. Fix parsing multiple segments in content-type header. Rework bitmap reference counting to be more robust. Fix WebP decoding on API < 19 devices. Expose FetchResult and DecodeResult in the EventListener API. Compile with SDK 30. Update Coroutines to 1.3.8. Update OkHttp to 3.12.12. Update Okio to 2.7.0. Update AndroidX dependencies: androidx.appcompat:appcompat-resources -> 1.2.0 androidx.core:core-ktx -> 1.3.1","title":"[0.12.0] - August 18, 2020"},{"location":"changelog/#0110-may-14-2020","text":"Breaking : This version removes all existing deprecated functions. This enables removing Coil's ContentProvider so it doesn't run any code at app startup. Breaking : Convert SparseIntArraySet.size to a val. ( #380 ) Breaking : Move Parameters.count() to an extension function. ( #403 ) Breaking : Make BitmapPool.maxSize an Int. ( #404 ) Important : Make ImageLoader.shutdown() optional (similar to OkHttpClient ). ( #385 ) Fix: Fix AGP 4.1 compatibility. ( #386 ) Fix: Fix measuring GONE views. ( #397 ) Reduce the default memory cache size to 20%. ( #390 ) To restore the existing behaviour set ImageLoaderBuilder.availableMemoryPercentage(0.25) when creating your ImageLoader . Update Coroutines to 1.3.6. Update OkHttp to 3.12.11.","title":"[0.11.0] - May 14, 2020"},{"location":"changelog/#0101-april-26-2020","text":"Fix OOM when decoding large PNGs on API 23 and below. ( #372 ). This disables decoding EXIF orientation for PNG files. PNG EXIF orientation is very rarely used and reading PNG EXIF data (even if it's empty) requires buffering the entire file into memory, which is bad for performance. Minor Java compatibility improvements to SparseIntArraySet . Update Okio to 2.6.0.","title":"[0.10.1] - April 26, 2020"},{"location":"changelog/#0100-april-20-2020","text":"","title":"[0.10.0] - April 20, 2020"},{"location":"changelog/#highlights","text":"This version deprecates most of the DSL API in favour of using the builders directly. Here's what the change looks like: // 0.9.5 (old) val imageLoader = ImageLoader ( context ) { bitmapPoolPercentage ( 0.5 ) crossfade ( true ) } val disposable = imageLoader . load ( context , \"https://www.example.com/image.jpg\" ) { target ( imageView ) } val drawable = imageLoader . get ( \"https://www.example.com/image.jpg\" ) { size ( 512 , 512 ) } // 0.10.0 (new) val imageLoader = ImageLoader . Builder ( context ) . bitmapPoolPercentage ( 0.5 ) . crossfade ( true ) . build () val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . execute ( request ) val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 512 , 512 ) . build () val drawable = imageLoader . execute ( request ). drawable If you're using the io.coil-kt:coil artifact, you can call Coil.execute(request) to execute the request with the singleton ImageLoader . ImageLoader s now have a weak reference memory cache that tracks weak references to images once they're evicted from the strong reference memory cache. This means an image will always be returned from an ImageLoader 's memory cache if there's still a strong reference to it. Generally, this should make the memory cache much more predictable and increase its hit rate. This behaviour can be enabled/disabled with ImageLoaderBuilder.trackWeakReferences . Add a new artifact, io.coil-kt:coil-video , to decode specific frames from a video file. Read more here . Add a new EventListener API for tracking metrics. Add ImageLoaderFactory which can be implemented by your Application to simplify singleton initialization.","title":"Highlights"},{"location":"changelog/#full-release-notes","text":"Important : Deprecate DSL syntax in favour of builder syntax. ( #267 ) Important : Deprecate Coil and ImageLoader extension functions. ( #322 ) Breaking : Return sealed RequestResult type from ImageLoader.execute(GetRequest) . ( #349 ) Breaking : Rename ExperimentalCoil to ExperimentalCoilApi . Migrate from @Experimental to @RequiresOptIn . ( #306 ) Breaking : Replace CoilLogger with Logger interface. ( #316 ) Breaking : Rename destWidth/destHeight to dstWidth/dstHeight. ( #275 ) Breaking : Re-arrange MovieDrawable 's constructor params. ( #272 ) Breaking : Request.Listener 's methods now receive the full Request object instead of just its data. Breaking : GetRequestBuilder now requires a Context in its constructor. Breaking : Several properties on Request are now nullable. Behaviour change : Include parameter values in the cache key by default. ( #319 ) Behaviour change : Slightly adjust Request.Listener.onStart() timing to be called immediately after Target.onStart() . ( #348 ) New : Add WeakMemoryCache implementation. ( #295 ) New : Add coil-video to support decoding video frames. ( #122 ) New : Introduce EventListener . ( #314 ) New : Introduce ImageLoaderFactory . ( #311 ) New : Support animated HEIF image sequences on Android 11. ( #297 ) New : Improve Java compatibility. ( #262 ) New : Support setting a default CachePolicy . ( #307 ) New : Support setting a default Bitmap.Config . ( #342 ) New : Add ImageLoader.invalidate(key) to clear a single memory cache item ( #55 ) New : Add debug logs to explain why a cached image is not reused. ( #346 ) New : Support error and fallback drawables for get requests. Fix: Fix memory cache miss when Transformation reduces input bitmap's size. ( #357 ) Fix: Ensure radius is below RenderScript max in BlurTransformation. ( #291 ) Fix: Fix decoding high colour depth images. ( #358 ) Fix: Disable ImageDecoderDecoder crash work-around on Android 11 and above. ( #298 ) Fix: Fix failing to read EXIF data on pre-API 23. ( #331 ) Fix: Fix incompatibility with Android R SDK. ( #337 ) Fix: Only enable inexact size if ImageView has a matching SizeResolver . ( #344 ) Fix: Allow cached images to be at most one pixel off requested size. ( #360 ) Fix: Skip crossfade transition if view is not visible. ( #361 ) Deprecate CoilContentProvider . ( #293 ) Annotate several ImageLoader methods with @MainThread . Avoid creating a LifecycleCoroutineDispatcher if the lifecycle is currently started. ( #356 ) Use full package name for OriginalSize.toString() . Preallocate when decoding software bitmap. ( #354 ) Update Kotlin to 1.3.72. Update Coroutines to 1.3.5. Update OkHttp to 3.12.10. Update Okio to 2.5.0. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.2.0","title":"Full Release Notes"},{"location":"changelog/#095-february-6-2020","text":"Fix: Ensure a view is attached before checking if it is hardware accelerated. This fixes a case where requesting a hardware bitmap could miss the memory cache. Update AndroidX dependencies: androidx.core:core-ktx -> 1.2.0","title":"[0.9.5] - February 6, 2020"},{"location":"changelog/#094-february-3-2020","text":"Fix: Respect aspect ratio when downsampling in ImageDecoderDecoder. Thanks @zhanghai. Previously bitmaps would be returned from the memory cache as long as their config was greater than or equal to the config specified in the request. For example, if you requested an ARGB_8888 bitmap, it would be possible to have a RGBA_F16 bitmap returned to you from the memory cache. Now, the cached config and the requested config must be equal. Make scale and durationMillis public in CrossfadeDrawable and CrossfadeTransition .","title":"[0.9.4] - February 3, 2020"},{"location":"changelog/#093-february-1-2020","text":"Fix: Translate child drawable inside ScaleDrawable to ensure it is centered. Fix: Fix case where GIFs and SVGs would not fill bounds completely. Defer calling HttpUrl.get() to background thread. Improve BitmapFactory null bitmap error message. Add 3 devices to hardware bitmap blacklist. ( #264 ) Update AndroidX dependencies: androidx.lifecycle:lifecycle-common-java8 -> 2.2.0","title":"[0.9.3] - February 1, 2020"},{"location":"changelog/#092-january-19-2020","text":"Fix: Fix decoding GIFs on pre-API 19. Thanks @mario. Fix: Fix rasterized vector drawables not being marked as sampled. Fix: Throw exception if Movie dimensions are <= 0. Fix: Fix CrossfadeTransition not being resumed for a memory cache event. Fix: Prevent returning hardware bitmaps to all target methods if disallowed. Fix: Fix MovieDrawable not positioning itself in the center of its bounds. Remove automatic scaling from CrossfadeDrawable. Make BitmapPool.trimMemory public. Wrap AnimatedImageDrawable in a ScaleDrawable to ensure it fills its bounds. Add @JvmOverloads to RequestBuilder.setParameter. Set an SVG's view box to its size if the view box is not set. Pass state and level changes to CrossfadeDrawable children. Update OkHttp to 3.12.8.","title":"[0.9.2] - January 19, 2020"},{"location":"changelog/#091-december-30-2019","text":"Fix: Fix crash when calling LoadRequestBuilder.crossfade(false) .","title":"[0.9.1] - December 30, 2019"},{"location":"changelog/#090-december-30-2019","text":"Breaking : Transformation.transform now includes a Size parameter. This is to support transformations that change the size of the output Bitmap based on the size of the Target . Requests with transformations are now also exempt from image sampling . Breaking : Transformation s are now applied to any type of Drawable . Before, Transformation s would be skipped if the input Drawable was not a BitmapDrawable . Now, Drawable s are rendered to a Bitmap before applying the Transformation s. Breaking : Passing null data to ImageLoader.load is now treated as an error and calls Target.onError and Request.Listener.onError with a NullRequestDataException . This change was made to support setting a fallback drawable if data is null . Previously the request was silently ignored. Breaking : RequestDisposable.isDisposed is now a val . New : Support for custom transitions. See here for more info . Transitions are marked as experimental as the API is incubating. New : Add RequestDisposable.await to support suspending while a LoadRequest is in progress. New : Support setting a fallback drawable when request data is null. New : Add Precision . This makes the size of the output Drawable exact while enabling scaling optimizations for targets that support scaling (e.g. ImageViewTarget ). See its documentation for more information. New : Add RequestBuilder.aliasKeys to support matching multiple cache keys. Fix: Make RequestDisposable thread safe. Fix: RoundedCornersTransformation now crops to the size of the target then rounds the corners. Fix: CircleCropTransformation now crops from the center. Fix: Add several devices to the hardware bitmap blacklist . Fix: Preserve aspect ratio when converting a Drawable to a Bitmap. Fix: Fix possible memory cache miss with Scale.FIT . Fix: Ensure Parameters iteration order is deterministic. Fix: Defensive copy when creating Parameters and ComponentRegistry. Fix: Ensure RealBitmapPool's maxSize >= 0. Fix: Show the start drawable if CrossfadeDrawable is not animating or done. Fix: Adjust CrossfadeDrawable to account for children with undefined intrinsic size. Fix: Fix MovieDrawable not scaling properly. Update Kotlin to 1.3.61. Update Kotlin Coroutines to 1.3.3. Update Okio to 2.4.3. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.1.0","title":"[0.9.0] - December 30, 2019"},{"location":"changelog/#080-october-22-2019","text":"Breaking : SvgDrawable has been removed. Instead, SVGs are now prerendered to BitmapDrawable s by SvgDecoder . This makes SVGs significantly less expensive to render on the main thread . Also SvgDecoder now requires a Context in its constructor. Breaking : SparseIntArraySet extension functions have moved to the coil.extension package. New : Support setting per-request network headers. See here for more info . New : Add new Parameters API to support passing custom data through the image pipeline. New : Support individual corner radii in RoundedCornersTransformation. Thanks @khatv911. New : Add ImageView.clear() to support proactively freeing resources. New : Support loading resources from other packages. New : Add subtractPadding attribute to ViewSizeResolver to enable/disable subtracting a view's padding when measuring. New : Improve HttpUrlFetcher MIME type detection. New : Add Animatable2Compat support to MovieDrawable and CrossfadeDrawable. New : Add RequestBuilder<*>.repeatCount to set the repeat count for a GIF. New : Add BitmapPool creation to the public API. New : Annotate Request.Listener methods with @MainThread . Fix: Make CoilContentProvider visible for testing. Fix: Include night mode in the resource cache key. Fix: Work around ImageDecoder native crash by temporarily writing the source to disk. Fix: Correctly handle contact display photo uris. Fix: Pass tint to CrossfadeDrawable's children. Fix: Fix several instances of not closing sources. Fix: Add a blacklist of devices with broken/incomplete hardware bitmap implementations. Compile against SDK 29. Update Kotlin Coroutines to 1.3.2. Update OkHttp to 3.12.6. Update Okio to 2.4.1. Change appcompat-resources from compileOnly to implementation for coil-base .","title":"[0.8.0] - October 22, 2019"},{"location":"changelog/#070-september-8-2019","text":"Breaking : ImageLoaderBuilder.okHttpClient(OkHttpClient.Builder.() -> Unit) is now ImageLoaderBuilder.okHttpClient(() -> OkHttpClient) . The initializer is also now called lazily on a background thread. If you set a custom OkHttpClient you must set OkHttpClient.cache to enable disk caching. If you don't set a custom OkHttpClient , Coil will create the default OkHttpClient which has disk caching enabled. The default Coil cache can be created using CoilUtils.createDefaultCache(context) . e.g.: val imageLoader = ImageLoader ( context ) { okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } } Breaking : Fetcher.key no longer has a default implementation. Breaking : Previously, only the first applicable Mapper would be called. Now, all applicable Mapper s will be called. No API changes. Breaking : Minor named parameter renaming: url -> uri , factory -> initializer . New : coil-svg artifact, which has an SvgDecoder that supports automatically decoding SVGs. Powered by AndroidSVG . Thanks @rharter. New : load(String) and get(String) now accept any of the supported Uri schemes. e.g. You can now do imageView.load(\"file:///path/to/file.jpg\") . New : Refactor ImageLoader to use Call.Factory instead of OkHttpClient . This allows lazy initialization of the networking resources using ImageLoaderBuilder.okHttpClient { OkHttpClient() } . Thanks @ZacSweers. New : RequestBuilder.decoder to explicitly set the decoder for a request. New : ImageLoaderBuilder.allowHardware to enable/disable hardware bitmaps by default for an ImageLoader. New : Support software rendering in ImageDecoderDecoder. Fix: Multiple bugs with loading vector drawables. Fix: Support WRAP_CONTENT View dimensions. Fix: Support parsing EXIF data longer than 8192 bytes. Fix: Don't stretch drawables with different aspect ratios when crossfading. Fix: Guard against network observer failing to register due to exception. Fix: Fix divide by zero error in MovieDrawable. Thanks @R12rus. Fix: Support nested Android asset files. Thanks @JaCzekanski. Fix: Guard against running out of file descriptors on Android O and O_MR1. Fix: Don't crash when disabling memory cache. Thanks @hansenji. Fix: Ensure Target.cancel is always called from the main thread. Update Kotlin to 1.3.50. Update Kotlin Coroutines to 1.3.0. Update OkHttp to 3.12.4. Update Okio to 2.4.0. Update AndroidX dependencies to the latest stable versions: androidx.appcompat:appcompat -> 1.1.0 androidx.core:core-ktx -> 1.1.0 androidx.lifecycle:lifecycle-common-java8 -> 2.1.0 Replace appcompat with appcompat-resources as an optional compileOnly dependency. appcompat-resources is a much smaller artifact.","title":"[0.7.0] - September 8, 2019"},{"location":"changelog/#061-august-16-2019","text":"New: Add transformations(List<Transformation>) to RequestBuilder. Fix: Add the last modified date to the cache key for file uris. Fix: Ensure View dimensions are evaluated to at least 1px. Fix: Clear MovieDrawable's canvas between frames. Fix: Open assets correctly.","title":"[0.6.1] - August 16, 2019"},{"location":"changelog/#060-august-12-2019","text":"Initial release.","title":"[0.6.0] - August 12, 2019"},{"location":"code_of_conduct/","text":"Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"compose/","text":"Jetpack Compose \u00b6 To add support for Jetpack Compose , import the extension library: implementation ( \"io.coil-kt:coil-compose:2.2.2\" ) Then use the AsyncImage composable to load and display an image: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null ) model can either be the ImageRequest.data value - or the ImageRequest itself. contentDescription sets the text used by accessibility services to describe what this image represents. AsyncImage \u00b6 AsyncImage is a composable that executes an image request asynchronously and renders the result. It supports the same arguments as the standard Image composable and additionally, it supports setting placeholder / error / fallback painters and onLoading / onSuccess / onError callbacks. Here's an example that loads an image with a circle crop, crossfade, and sets a placeholder: AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), placeholder = painterResource ( R . drawable . placeholder ), contentDescription = stringResource ( R . string . description ), contentScale = ContentScale . Crop , modifier = Modifier . clip ( CircleShape ) ) SubcomposeAsyncImage \u00b6 SubcomposeAsyncImage is a variant of AsyncImage that uses subcomposition to provide a slot API for AsyncImagePainter 's states instead of using Painter s. Here's an example: SubcomposeAsyncImage ( model = \"https://example.com/image.jpg\" , loading = { CircularProgressIndicator () }, contentDescription = stringResource ( R . string . description ) ) Additionally, you can have more complex logic using its content argument and SubcomposeAsyncImageContent , which renders the current state: SubcomposeAsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = stringResource ( R . string . description ) ) { val state = painter . state if ( state is AsyncImagePainter . State . Loading || state is AsyncImagePainter . State . Error ) { CircularProgressIndicator () } else { SubcomposeAsyncImageContent () } } Subcomposition is less performant than regular composition so this composable may not be suitable for parts of your UI where high performance is critical (e.g. lists). Note If you set a custom size for the ImageRequest using ImageRequest.Builder.size (e.g. size(Size.ORIGINAL) ), SubcomposeAsyncImage will not use subcomposition since it doesn't need to resolve the composable's constraints. AsyncImagePainter \u00b6 Internally, AsyncImage and SubcomposeAsyncImage use AsyncImagePainter to load the model . If you need a Painter and can't use AsyncImage , you can load the image using rememberAsyncImagePainter : val painter = rememberAsyncImagePainter ( \"https://example.com/image.jpg\" ) rememberAsyncImagePainter is a lower-level API that may not behave as expected in all cases. Read the method's documentation for more information. Note If you set a custom ContentScale on the Image that's rendering the AsyncImagePainter , you should also set it in rememberAsyncImagePainter . It's necessary to determine the correct dimensions to load the image at. Observing AsyncImagePainter.state \u00b6 An image request needs a size to determine the output image's dimensions. By default, both AsyncImage and AsyncImagePainter resolve the request's size after composition occurs , but before the first frame is drawn. It's resolved this way to maximize performance. This means that AsyncImagePainter.state will be Loading for the first composition - even if the image is present in the memory cache and it will be drawn in the first frame. If you need AsyncImagePainter.state to be up-to-date during the first composition, use SubcomposeAsyncImage or set a custom size for the image request using ImageRequest.Builder.size . For example, AsyncImagePainter.state will always be up-to-date during the first composition in this example: val painter = rememberAsyncImagePainter ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . size ( Size . ORIGINAL ) // Set the target size to load the image at. . build () ) if ( painter . state is AsyncImagePainter . State . Success ) { // This will be executed during the first composition if the image is in the memory cache. } Image ( painter = painter , contentDescription = stringResource ( R . string . description ) ) Transitions \u00b6 You can enable the built in crossfade transition using ImageRequest.Builder.crossfade : AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), contentDescription = null ) Custom Transition s do not work with AsyncImage , SubcomposeAsyncImage , or rememberAsyncImagePainter as they require a View reference. CrossfadeTransition works due to special internal support. That said, it's possible to create custom transitions in Compose by observing the AsyncImagePainter 's state: val painter = rememberAsyncImagePainter ( \"https://example.com/image.jpg\" ) val state = painter . state if ( state is AsyncImagePainter . State . Success && state . dataSource != DataSource . MEMORY_CACHE ) { // Perform the transition animation. } Image ( painter = painter , contentDescription = stringResource ( R . string . description ) )","title":"Jetpack Compose"},{"location":"compose/#jetpack-compose","text":"To add support for Jetpack Compose , import the extension library: implementation ( \"io.coil-kt:coil-compose:2.2.2\" ) Then use the AsyncImage composable to load and display an image: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null ) model can either be the ImageRequest.data value - or the ImageRequest itself. contentDescription sets the text used by accessibility services to describe what this image represents.","title":"Jetpack Compose"},{"location":"compose/#asyncimage","text":"AsyncImage is a composable that executes an image request asynchronously and renders the result. It supports the same arguments as the standard Image composable and additionally, it supports setting placeholder / error / fallback painters and onLoading / onSuccess / onError callbacks. Here's an example that loads an image with a circle crop, crossfade, and sets a placeholder: AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), placeholder = painterResource ( R . drawable . placeholder ), contentDescription = stringResource ( R . string . description ), contentScale = ContentScale . Crop , modifier = Modifier . clip ( CircleShape ) )","title":"AsyncImage"},{"location":"compose/#subcomposeasyncimage","text":"SubcomposeAsyncImage is a variant of AsyncImage that uses subcomposition to provide a slot API for AsyncImagePainter 's states instead of using Painter s. Here's an example: SubcomposeAsyncImage ( model = \"https://example.com/image.jpg\" , loading = { CircularProgressIndicator () }, contentDescription = stringResource ( R . string . description ) ) Additionally, you can have more complex logic using its content argument and SubcomposeAsyncImageContent , which renders the current state: SubcomposeAsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = stringResource ( R . string . description ) ) { val state = painter . state if ( state is AsyncImagePainter . State . Loading || state is AsyncImagePainter . State . Error ) { CircularProgressIndicator () } else { SubcomposeAsyncImageContent () } } Subcomposition is less performant than regular composition so this composable may not be suitable for parts of your UI where high performance is critical (e.g. lists). Note If you set a custom size for the ImageRequest using ImageRequest.Builder.size (e.g. size(Size.ORIGINAL) ), SubcomposeAsyncImage will not use subcomposition since it doesn't need to resolve the composable's constraints.","title":"SubcomposeAsyncImage"},{"location":"compose/#asyncimagepainter","text":"Internally, AsyncImage and SubcomposeAsyncImage use AsyncImagePainter to load the model . If you need a Painter and can't use AsyncImage , you can load the image using rememberAsyncImagePainter : val painter = rememberAsyncImagePainter ( \"https://example.com/image.jpg\" ) rememberAsyncImagePainter is a lower-level API that may not behave as expected in all cases. Read the method's documentation for more information. Note If you set a custom ContentScale on the Image that's rendering the AsyncImagePainter , you should also set it in rememberAsyncImagePainter . It's necessary to determine the correct dimensions to load the image at.","title":"AsyncImagePainter"},{"location":"compose/#observing-asyncimagepainterstate","text":"An image request needs a size to determine the output image's dimensions. By default, both AsyncImage and AsyncImagePainter resolve the request's size after composition occurs , but before the first frame is drawn. It's resolved this way to maximize performance. This means that AsyncImagePainter.state will be Loading for the first composition - even if the image is present in the memory cache and it will be drawn in the first frame. If you need AsyncImagePainter.state to be up-to-date during the first composition, use SubcomposeAsyncImage or set a custom size for the image request using ImageRequest.Builder.size . For example, AsyncImagePainter.state will always be up-to-date during the first composition in this example: val painter = rememberAsyncImagePainter ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . size ( Size . ORIGINAL ) // Set the target size to load the image at. . build () ) if ( painter . state is AsyncImagePainter . State . Success ) { // This will be executed during the first composition if the image is in the memory cache. } Image ( painter = painter , contentDescription = stringResource ( R . string . description ) )","title":"Observing AsyncImagePainter.state"},{"location":"compose/#transitions","text":"You can enable the built in crossfade transition using ImageRequest.Builder.crossfade : AsyncImage ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://example.com/image.jpg\" ) . crossfade ( true ) . build (), contentDescription = null ) Custom Transition s do not work with AsyncImage , SubcomposeAsyncImage , or rememberAsyncImagePainter as they require a View reference. CrossfadeTransition works due to special internal support. That said, it's possible to create custom transitions in Compose by observing the AsyncImagePainter 's state: val painter = rememberAsyncImagePainter ( \"https://example.com/image.jpg\" ) val state = painter . state if ( state is AsyncImagePainter . State . Success && state . dataSource != DataSource . MEMORY_CACHE ) { // Perform the transition animation. } Image ( painter = painter , contentDescription = stringResource ( R . string . description ) )","title":"Transitions"},{"location":"contributing/","text":"Contributing \u00b6 In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. Issues that are tagged as help wanted are great issues to get started contributing to Coil. If you have a new feature idea, please create an enhancement request so it can be discussed or build it in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . If you are making an API change, run ./gradlew apiDump and include any changed files in your pull request. Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"contributing/#contributing","text":"In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. Issues that are tagged as help wanted are great issues to get started contributing to Coil. If you have a new feature idea, please create an enhancement request so it can be discussed or build it in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . If you are making an API change, run ./gradlew apiDump and include any changed files in your pull request. Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"faq/","text":"FAQ \u00b6 Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search Github discussions . Can Coil be used with Java projects or mixed Kotlin/Java projects? \u00b6 Yes! Read here . How do I preload an image? \u00b6 Read here . How do I enable logging? \u00b6 Set logger(DebugLogger()) when constructing your ImageLoader . Note DebugLogger should only be used in debug builds. How do I target Java 8? \u00b6 Coil requires Java 8 bytecode . This is enabled by default on the Android Gradle Plugin 4.2.0 and later and the Kotlin Gradle Plugin 1.5.0 and later. If you're using older versions of those plugins add the following to your Gradle build script: Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } How do I get development snapshots? \u00b6 Add the snapshots repository to your list of repositories: Gradle ( .gradle ): allprojects { repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } } Gradle Kotlin DSL ( .gradle.kts ): allprojects { repositories { maven ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Then depend on the same artifacts with the latest snapshot version . Note Snapshots are deployed for each new commit on main that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.","title":"FAQ"},{"location":"faq/#faq","text":"Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search Github discussions .","title":"FAQ"},{"location":"faq/#can-coil-be-used-with-java-projects-or-mixed-kotlinjava-projects","text":"Yes! Read here .","title":"Can Coil be used with Java projects or mixed Kotlin/Java projects?"},{"location":"faq/#how-do-i-preload-an-image","text":"Read here .","title":"How do I preload an image?"},{"location":"faq/#how-do-i-enable-logging","text":"Set logger(DebugLogger()) when constructing your ImageLoader . Note DebugLogger should only be used in debug builds.","title":"How do I enable logging?"},{"location":"faq/#how-do-i-target-java-8","text":"Coil requires Java 8 bytecode . This is enabled by default on the Android Gradle Plugin 4.2.0 and later and the Kotlin Gradle Plugin 1.5.0 and later. If you're using older versions of those plugins add the following to your Gradle build script: Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } }","title":"How do I target Java 8?"},{"location":"faq/#how-do-i-get-development-snapshots","text":"Add the snapshots repository to your list of repositories: Gradle ( .gradle ): allprojects { repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } } Gradle Kotlin DSL ( .gradle.kts ): allprojects { repositories { maven ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Then depend on the same artifacts with the latest snapshot version . Note Snapshots are deployed for each new commit on main that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.","title":"How do I get development snapshots?"},{"location":"getting_started/","text":"Getting Started \u00b6 Artifacts \u00b6 Coil has 8 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact which depends on io.coil-kt:coil-base , creates a singleton ImageLoader , and includes the ImageView extension functions. io.coil-kt:coil-base : A subset of io.coil-kt:coil which does not include the singleton ImageLoader and the ImageView extension functions. io.coil-kt:coil-compose : Includes support for Jetpack Compose . io.coil-kt:coil-compose-base : A subset of io.coil-kt:coil-compose which does not include functions that depend on the singleton ImageLoader . io.coil-kt:coil-gif : Includes two decoders to support decoding GIFs. See GIFs for more details. io.coil-kt:coil-svg : Includes a decoder to support decoding SVGs. See SVGs for more details. io.coil-kt:coil-video : Includes a decoder to support decoding frames from any of Android's supported video formats . See videos for more details. io.coil-kt:coil-bom : Includes a bill of materials . Importing coil-bom allows you to depend on other Coil artifacts without specifying a version. Image Loaders \u00b6 ImageLoader s are service classes that execute ImageRequest s. ImageLoader s handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. The default Coil artifact ( io.coil-kt:coil ) includes the singleton ImageLoader , which can be accessed using an extension function: context.imageLoader . The singleton ImageLoader can be configured by implementing ImageLoaderFactory on your Application class: class MyApplication : Application (), ImageLoaderFactory { override fun newImageLoader (): ImageLoader { return ImageLoader . Builder ( this ) . crossfade ( true ) . build () } } Implementing ImageLoaderFactory is optional. If you don't, Coil will lazily create an ImageLoader with the default values. Check out the full documentation for more info. Image Requests \u00b6 ImageRequest s are value classes that are executed by ImageLoader s. They describe where an image should be loaded from, how it should be loaded, and any extra parameters. An ImageLoader has two methods that can execute a request: enqueue : Enqueues the ImageRequest to be executed asynchronously on a background thread. execute : Executes the ImageRequest in the current coroutine and returns an ImageResult . All requests should set data (i.e. url, uri, file, drawable resource, etc.). This is what the ImageLoader will use to decide where to fetch the image data from. If you do not set data , it will default to NullRequestData . Additionally, you likely want to set a target when enqueuing a request. It's optional, but the target is what will receive the loaded placeholder/success/error drawables. Executed requests return an ImageResult which has the success/error drawable. Here's an example: // enqueue val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . enqueue ( request ) // execute val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request ) ImageView Extension Functions \u00b6 The io.coil-kt:coil artifact provides a set of ImageView extension functions. Here's an example for loading a URL into an ImageView : imageView . load ( \"https://www.example.com/image.jpg\" ) The above call is equivalent to: val imageLoader = imageView . context . imageLoader val request = ImageRequest . Builder ( imageView . context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () imageLoader . enqueue ( request ) ImageView.load calls can be configured with an optional trailing lambda parameter: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here for more information. Supported Data Types \u00b6 The base data types that are supported by all ImageLoader instances are: String (mapped to a Uri) HttpUrl Uri ( android.resource , content , file , http , and https schemes) File @DrawableRes Int Drawable Bitmap ByteArray ByteBuffer Supported Image Formats \u00b6 All ImageLoader s support the following non-animated file types: BMP JPEG PNG WebP HEIF (Android 8.0+) Additionally, Coil has extension libraries for the following file types: coil-gif : GIF, animated WebP (Android 9.0+), animated HEIF (Android 11.0+) coil-svg : SVG coil-video : Static video frames from any video codec supported by Android Preloading \u00b6 To preload an image into memory, enqueue or execute an ImageRequest without a Target : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) // Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at. . size ( ViewSizeResolver ( imageView )) . build () imageLoader . enqueue ( request ) To preload a network image only into the disk cache, disable the memory cache for the request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . memoryCachePolicy ( CachePolicy . DISABLED ) . build () imageLoader . enqueue ( request ) Cancelling Requests \u00b6 ImageRequest s will be automatically cancelled in the following cases: request.lifecycle reaches the DESTROYED state. request.target is a ViewTarget and its View is detached. Additionally, ImageLoader.enqueue returns a Disposable , which can be used to dispose the request (which cancels it and frees its associated resources): val disposable = imageView . load ( \"https://www.example.com/image.jpg\" ) // Cancel the request. disposable . dispose ()","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#artifacts","text":"Coil has 8 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact which depends on io.coil-kt:coil-base , creates a singleton ImageLoader , and includes the ImageView extension functions. io.coil-kt:coil-base : A subset of io.coil-kt:coil which does not include the singleton ImageLoader and the ImageView extension functions. io.coil-kt:coil-compose : Includes support for Jetpack Compose . io.coil-kt:coil-compose-base : A subset of io.coil-kt:coil-compose which does not include functions that depend on the singleton ImageLoader . io.coil-kt:coil-gif : Includes two decoders to support decoding GIFs. See GIFs for more details. io.coil-kt:coil-svg : Includes a decoder to support decoding SVGs. See SVGs for more details. io.coil-kt:coil-video : Includes a decoder to support decoding frames from any of Android's supported video formats . See videos for more details. io.coil-kt:coil-bom : Includes a bill of materials . Importing coil-bom allows you to depend on other Coil artifacts without specifying a version.","title":"Artifacts"},{"location":"getting_started/#image-loaders","text":"ImageLoader s are service classes that execute ImageRequest s. ImageLoader s handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. The default Coil artifact ( io.coil-kt:coil ) includes the singleton ImageLoader , which can be accessed using an extension function: context.imageLoader . The singleton ImageLoader can be configured by implementing ImageLoaderFactory on your Application class: class MyApplication : Application (), ImageLoaderFactory { override fun newImageLoader (): ImageLoader { return ImageLoader . Builder ( this ) . crossfade ( true ) . build () } } Implementing ImageLoaderFactory is optional. If you don't, Coil will lazily create an ImageLoader with the default values. Check out the full documentation for more info.","title":"Image Loaders"},{"location":"getting_started/#image-requests","text":"ImageRequest s are value classes that are executed by ImageLoader s. They describe where an image should be loaded from, how it should be loaded, and any extra parameters. An ImageLoader has two methods that can execute a request: enqueue : Enqueues the ImageRequest to be executed asynchronously on a background thread. execute : Executes the ImageRequest in the current coroutine and returns an ImageResult . All requests should set data (i.e. url, uri, file, drawable resource, etc.). This is what the ImageLoader will use to decide where to fetch the image data from. If you do not set data , it will default to NullRequestData . Additionally, you likely want to set a target when enqueuing a request. It's optional, but the target is what will receive the loaded placeholder/success/error drawables. Executed requests return an ImageResult which has the success/error drawable. Here's an example: // enqueue val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . enqueue ( request ) // execute val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request )","title":"Image Requests"},{"location":"getting_started/#imageview-extension-functions","text":"The io.coil-kt:coil artifact provides a set of ImageView extension functions. Here's an example for loading a URL into an ImageView : imageView . load ( \"https://www.example.com/image.jpg\" ) The above call is equivalent to: val imageLoader = imageView . context . imageLoader val request = ImageRequest . Builder ( imageView . context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () imageLoader . enqueue ( request ) ImageView.load calls can be configured with an optional trailing lambda parameter: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here for more information.","title":"ImageView Extension Functions"},{"location":"getting_started/#supported-data-types","text":"The base data types that are supported by all ImageLoader instances are: String (mapped to a Uri) HttpUrl Uri ( android.resource , content , file , http , and https schemes) File @DrawableRes Int Drawable Bitmap ByteArray ByteBuffer","title":"Supported Data Types"},{"location":"getting_started/#supported-image-formats","text":"All ImageLoader s support the following non-animated file types: BMP JPEG PNG WebP HEIF (Android 8.0+) Additionally, Coil has extension libraries for the following file types: coil-gif : GIF, animated WebP (Android 9.0+), animated HEIF (Android 11.0+) coil-svg : SVG coil-video : Static video frames from any video codec supported by Android","title":"Supported Image Formats"},{"location":"getting_started/#preloading","text":"To preload an image into memory, enqueue or execute an ImageRequest without a Target : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) // Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at. . size ( ViewSizeResolver ( imageView )) . build () imageLoader . enqueue ( request ) To preload a network image only into the disk cache, disable the memory cache for the request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . memoryCachePolicy ( CachePolicy . DISABLED ) . build () imageLoader . enqueue ( request )","title":"Preloading"},{"location":"getting_started/#cancelling-requests","text":"ImageRequest s will be automatically cancelled in the following cases: request.lifecycle reaches the DESTROYED state. request.target is a ViewTarget and its View is detached. Additionally, ImageLoader.enqueue returns a Disposable , which can be used to dispose the request (which cancels it and frees its associated resources): val disposable = imageView . load ( \"https://www.example.com/image.jpg\" ) // Cancel the request. disposable . dispose ()","title":"Cancelling Requests"},{"location":"gifs/","text":"Gifs \u00b6 Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them. To add GIF support, import the extension library: implementation ( \"io.coil-kt:coil-gif:2.2.2\" ) And add the decoders to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . components { if ( SDK_INT >= 28 ) { add ( ImageDecoderDecoder . Factory ()) } else { add ( GifDecoder . Factory ()) } } . build () And that's it! The ImageLoader will automatically detect any GIFs using their file headers and decode them correctly. To transform the pixel data of each frame of a GIF, see AnimatedTransformation . Note Coil includes two separate decoders to support decoding GIFs. GifDecoder supports all API levels, but is slower. ImageDecoderDecoder is powered by Android's ImageDecoder API which is only available on API 28 and above. ImageDecoderDecoder is faster than GifDecoder and supports decoding animated WebP images and animated HEIF image sequences.","title":"GIFs"},{"location":"gifs/#gifs","text":"Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them. To add GIF support, import the extension library: implementation ( \"io.coil-kt:coil-gif:2.2.2\" ) And add the decoders to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . components { if ( SDK_INT >= 28 ) { add ( ImageDecoderDecoder . Factory ()) } else { add ( GifDecoder . Factory ()) } } . build () And that's it! The ImageLoader will automatically detect any GIFs using their file headers and decode them correctly. To transform the pixel data of each frame of a GIF, see AnimatedTransformation . Note Coil includes two separate decoders to support decoding GIFs. GifDecoder supports all API levels, but is slower. ImageDecoderDecoder is powered by Android's ImageDecoder API which is only available on API 28 and above. ImageDecoderDecoder is faster than GifDecoder and supports decoding animated WebP images and animated HEIF image sequences.","title":"Gifs"},{"location":"image_loaders/","text":"Image Loaders \u00b6 ImageLoader s are service objects that execute ImageRequest s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, disk cache, and OkHttpClient . Caching \u00b6 Each ImageLoader keeps a memory cache of recently decoded Bitmap s as well as a disk cache for any images loaded from the Internet. Both can be configured when creating an ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . memoryCache { MemoryCache . Builder ( context ) . maxSizePercent ( 0.25 ) . build () } . diskCache { DiskCache . Builder () . directory ( context . cacheDir . resolve ( \"image_cache\" )) . maxSizePercent ( 0.02 ) . build () } . build () You can access items in the memory and disk caches using their keys, which are returned in an ImageResult after an image is loaded. The ImageResult is returned by ImageLoader.execute or in ImageRequest.Listener.onSuccess and ImageRequest.Listener.onError . Note Coil 1.x relied on OkHttp's disk cache. Coil 2.x has its own disk cache and should not use OkHttp's Cache . Singleton vs. Dependency Injection \u00b6 The default Coil artifact ( io.coil-kt:coil ) includes the singleton ImageLoader , which can be accessed using an extension function: context.imageLoader . Coil performs best when you have a single ImageLoader that's shared throughout your app. This is because each ImageLoader has its own set of resources. The singleton ImageLoader can be configured by implementing ImageLoaderFactory on your Application class. Optionally, you can create your own ImageLoader instance(s) and inject them using a dependency injector like Dagger . If you do that, depend on io.coil-kt:coil-base as that artifact doesn't create the singleton ImageLoader . Testing \u00b6 ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could create a fake ImageLoader implementation which always returns the same Drawable synchronously: class FakeImageLoader ( private val context : Context ) : ImageLoader { override val defaults = DefaultRequestOptions () override val components = ComponentRegistry () override val memoryCache : MemoryCache? get () = null override val diskCache : DiskCache? get () = null override fun enqueue ( request : ImageRequest ): Disposable { // Always call onStart before onSuccess. request . target ?. onStart ( request . placeholder ) val result = ColorDrawable ( Color . BLACK ) request . target ?. onSuccess ( result ) return object : Disposable { override val job = CompletableDeferred ( newResult ( request , result )) override val isDisposed get () = true override fun dispose () {} } } override suspend fun execute ( request : ImageRequest ): ImageResult { return newResult ( request , ColorDrawable ( Color . BLACK )) } private fun newResult ( request : ImageRequest , drawable : Drawable ): SuccessResult { return SuccessResult ( drawable = drawable , request = request , dataSource = DataSource . MEMORY_CACHE ) } override fun newBuilder () = throw UnsupportedOperationException () override fun shutdown () {} } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Image Loaders"},{"location":"image_loaders/#image-loaders","text":"ImageLoader s are service objects that execute ImageRequest s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, disk cache, and OkHttpClient .","title":"Image Loaders"},{"location":"image_loaders/#caching","text":"Each ImageLoader keeps a memory cache of recently decoded Bitmap s as well as a disk cache for any images loaded from the Internet. Both can be configured when creating an ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . memoryCache { MemoryCache . Builder ( context ) . maxSizePercent ( 0.25 ) . build () } . diskCache { DiskCache . Builder () . directory ( context . cacheDir . resolve ( \"image_cache\" )) . maxSizePercent ( 0.02 ) . build () } . build () You can access items in the memory and disk caches using their keys, which are returned in an ImageResult after an image is loaded. The ImageResult is returned by ImageLoader.execute or in ImageRequest.Listener.onSuccess and ImageRequest.Listener.onError . Note Coil 1.x relied on OkHttp's disk cache. Coil 2.x has its own disk cache and should not use OkHttp's Cache .","title":"Caching"},{"location":"image_loaders/#singleton-vs-dependency-injection","text":"The default Coil artifact ( io.coil-kt:coil ) includes the singleton ImageLoader , which can be accessed using an extension function: context.imageLoader . Coil performs best when you have a single ImageLoader that's shared throughout your app. This is because each ImageLoader has its own set of resources. The singleton ImageLoader can be configured by implementing ImageLoaderFactory on your Application class. Optionally, you can create your own ImageLoader instance(s) and inject them using a dependency injector like Dagger . If you do that, depend on io.coil-kt:coil-base as that artifact doesn't create the singleton ImageLoader .","title":"Singleton vs. Dependency Injection"},{"location":"image_loaders/#testing","text":"ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could create a fake ImageLoader implementation which always returns the same Drawable synchronously: class FakeImageLoader ( private val context : Context ) : ImageLoader { override val defaults = DefaultRequestOptions () override val components = ComponentRegistry () override val memoryCache : MemoryCache? get () = null override val diskCache : DiskCache? get () = null override fun enqueue ( request : ImageRequest ): Disposable { // Always call onStart before onSuccess. request . target ?. onStart ( request . placeholder ) val result = ColorDrawable ( Color . BLACK ) request . target ?. onSuccess ( result ) return object : Disposable { override val job = CompletableDeferred ( newResult ( request , result )) override val isDisposed get () = true override fun dispose () {} } } override suspend fun execute ( request : ImageRequest ): ImageResult { return newResult ( request , ColorDrawable ( Color . BLACK )) } private fun newResult ( request : ImageRequest , drawable : Drawable ): SuccessResult { return SuccessResult ( drawable = drawable , request = request , dataSource = DataSource . MEMORY_CACHE ) } override fun newBuilder () = throw UnsupportedOperationException () override fun shutdown () {} } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Testing"},{"location":"image_pipeline/","text":"Extending the Image Pipeline \u00b6 Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, MP4, etc.) Fortunately, ImageLoader s support pluggable components to add new cache layers, new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of five main parts that are executed in the following order: Interceptors , Mappers , Keyers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader . Builder ( context ) . components { add ( CustomCacheInterceptor ()) add ( ItemMapper ()) add ( HttpUrlKeyer ()) add ( CronetFetcher . Factory ()) add ( GifDecoder . Factory ()) } . build () Interceptors \u00b6 Interceptors allow you to observe, transform, short circuit, or retry requests to an ImageLoader 's image engine. For example, you can add a custom cache layer like so: class CustomCacheInterceptor ( private val context : Context , private val cache : LruCache < String , Drawable > ) : Interceptor { override suspend fun intercept ( chain : Interceptor . Chain ): ImageResult { val value = cache . get ( chain . request . data . toString ()) if ( value != null ) { return SuccessResult ( drawable = value . bitmap . toDrawable ( context ), request = chain . request , dataSource = DataSource . MEMORY_CACHE ) } return chain . proceed ( chain . request ) } } Interceptors are an advanced feature that let you wrap an ImageLoader 's image pipeline with custom logic. Their design is heavily based on OkHttp's Interceptor interface . See Interceptor for more information. Mappers \u00b6 Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to its URL, which will be handled later in the pipeline: class ItemMapper : Mapper < Item , String > { override fun map ( data : Item , options : Options ) = data . imageUrl } After registering it when building our ImageLoader (see above), we can safely load an Item : val request = ImageRequest . Builder ( context ) . data ( item ) . target ( imageView ) . build () imageLoader . enqueue ( request ) See Mapper for more information. Keyers \u00b6 Keyers convert data into a portion of a cache key. This value is used as MemoryCache.Key.key when/if this request's output is written to the MemoryCache . See Keyers for more information. Fetchers \u00b6 Fetchers translate data (e.g. URL, URI, File, etc.) into either an ImageSource or a Drawable . They typically convert the input data into a format that can then be consumed by a Decoder . Use this interface to add support for custom fetching mechanisms (e.g. Cronet, custom URI schemes, etc.) See Fetcher for more information. Decoders \u00b6 Decoders read an ImageSource and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information.","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#extending-the-image-pipeline","text":"Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, MP4, etc.) Fortunately, ImageLoader s support pluggable components to add new cache layers, new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of five main parts that are executed in the following order: Interceptors , Mappers , Keyers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader . Builder ( context ) . components { add ( CustomCacheInterceptor ()) add ( ItemMapper ()) add ( HttpUrlKeyer ()) add ( CronetFetcher . Factory ()) add ( GifDecoder . Factory ()) } . build ()","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#interceptors","text":"Interceptors allow you to observe, transform, short circuit, or retry requests to an ImageLoader 's image engine. For example, you can add a custom cache layer like so: class CustomCacheInterceptor ( private val context : Context , private val cache : LruCache < String , Drawable > ) : Interceptor { override suspend fun intercept ( chain : Interceptor . Chain ): ImageResult { val value = cache . get ( chain . request . data . toString ()) if ( value != null ) { return SuccessResult ( drawable = value . bitmap . toDrawable ( context ), request = chain . request , dataSource = DataSource . MEMORY_CACHE ) } return chain . proceed ( chain . request ) } } Interceptors are an advanced feature that let you wrap an ImageLoader 's image pipeline with custom logic. Their design is heavily based on OkHttp's Interceptor interface . See Interceptor for more information.","title":"Interceptors"},{"location":"image_pipeline/#mappers","text":"Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to its URL, which will be handled later in the pipeline: class ItemMapper : Mapper < Item , String > { override fun map ( data : Item , options : Options ) = data . imageUrl } After registering it when building our ImageLoader (see above), we can safely load an Item : val request = ImageRequest . Builder ( context ) . data ( item ) . target ( imageView ) . build () imageLoader . enqueue ( request ) See Mapper for more information.","title":"Mappers"},{"location":"image_pipeline/#keyers","text":"Keyers convert data into a portion of a cache key. This value is used as MemoryCache.Key.key when/if this request's output is written to the MemoryCache . See Keyers for more information.","title":"Keyers"},{"location":"image_pipeline/#fetchers","text":"Fetchers translate data (e.g. URL, URI, File, etc.) into either an ImageSource or a Drawable . They typically convert the input data into a format that can then be consumed by a Decoder . Use this interface to add support for custom fetching mechanisms (e.g. Cronet, custom URI schemes, etc.) See Fetcher for more information.","title":"Fetchers"},{"location":"image_pipeline/#decoders","text":"Decoders read an ImageSource and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information.","title":"Decoders"},{"location":"image_requests/","text":"Image Requests \u00b6 ImageRequest s are value objects that provide all the necessary information for an ImageLoader to load an image. ImageRequest s can be created using a builder: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build () Once you've created a request pass it to an ImageLoader to enqueue/execute it: imageLoader . enqueue ( request ) See the API documentation for more information.","title":"Image Requests"},{"location":"image_requests/#image-requests","text":"ImageRequest s are value objects that provide all the necessary information for an ImageLoader to load an image. ImageRequest s can be created using a builder: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build () Once you've created a request pass it to an ImageLoader to enqueue/execute it: imageLoader . enqueue ( request ) See the API documentation for more information.","title":"Image Requests"},{"location":"java_compatibility/","text":"Java Compatibility \u00b6 Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Importantly, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. Despite these limitations, most of Coil's API is Java compatible. The Context.imageLoader extension function should not be used from Java. Instead, you can get the singleton ImageLoader using: ImageLoader imageLoader = Coil . imageLoader ( context ) The syntax to enqueue an ImageRequest is almost the same in Java and Kotlin: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . enqueue ( request ) Note ImageView.load cannot be used from Java. Use the ImageRequest.Builder API instead. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to use the ImageLoader.executeBlocking extension function which can be called from Java like so: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaders . executeBlocking ( imageLoader , request ). getDrawable (); Note ImageLoaders.executeBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"java_compatibility/#java-compatibility","text":"Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Importantly, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. Despite these limitations, most of Coil's API is Java compatible. The Context.imageLoader extension function should not be used from Java. Instead, you can get the singleton ImageLoader using: ImageLoader imageLoader = Coil . imageLoader ( context ) The syntax to enqueue an ImageRequest is almost the same in Java and Kotlin: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . enqueue ( request ) Note ImageView.load cannot be used from Java. Use the ImageRequest.Builder API instead. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to use the ImageLoader.executeBlocking extension function which can be called from Java like so: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaders . executeBlocking ( imageLoader , request ). getDrawable (); Note ImageLoaders.executeBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"migrating/","text":"Migrating from Glide/Picasso \u00b6 Here are a few examples of how to migrate Glide/Picasso calls into Coil calls: Basic Usage \u00b6 // Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url ) Custom Requests \u00b6 imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (automatically detects the scale type) imageView . load ( url ) { placeholder ( placeholder ) } Non-View Targets \u00b6 // Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget < Drawable > () { override fun onResourceReady ( resource : Drawable , transition : Transition < Drawable > ) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable?) { // Handle the placeholder drawable. } }) // Coil val request = ImageRequest . Builder ( context ) . data ( url ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () context . imageLoader . enqueue ( request ) Background Thread \u00b6 // Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current coroutine; non-blocking and thread safe) val request = ImageRequest . Builder ( context ) . data ( url ) . size ( width , height ) . build () val drawable = context . imageLoader . execute ( request ). drawable","title":"Migrating from Glide/Picasso"},{"location":"migrating/#migrating-from-glidepicasso","text":"Here are a few examples of how to migrate Glide/Picasso calls into Coil calls:","title":"Migrating from Glide/Picasso"},{"location":"migrating/#basic-usage","text":"// Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url )","title":"Basic Usage"},{"location":"migrating/#custom-requests","text":"imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (automatically detects the scale type) imageView . load ( url ) { placeholder ( placeholder ) }","title":"Custom Requests"},{"location":"migrating/#non-view-targets","text":"// Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget < Drawable > () { override fun onResourceReady ( resource : Drawable , transition : Transition < Drawable > ) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable?) { // Handle the placeholder drawable. } }) // Coil val request = ImageRequest . Builder ( context ) . data ( url ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () context . imageLoader . enqueue ( request )","title":"Non-View Targets"},{"location":"migrating/#background-thread","text":"// Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current coroutine; non-blocking and thread safe) val request = ImageRequest . Builder ( context ) . data ( url ) . size ( width , height ) . build () val drawable = context . imageLoader . execute ( request ). drawable","title":"Background Thread"},{"location":"recipes/","text":"Recipes \u00b6 This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fit your exact requirements, but it should hopefully give you a push in the right direction! See a common use case that isn't covered? Feel free to submit a PR with a new section. Palette \u00b6 Palette allows you to extract prominent colors from an image. To create a Palette , you'll need access to an image's Bitmap . This can be done in a number of ways: You can get access to an image's bitmap by setting a ImageRequest.Listener and enqueuing an ImageRequest : imageView . load ( \"https://www.example.com/image.jpg\" ) { // Disable hardware bitmaps as Palette needs to read the image's pixels. allowHardware ( false ) listener ( onSuccess = { _ , result -> // Create the palette on a background thread. Palette . Builder ( result . drawable . toBitmap ()). generate { palette -> // Consume the palette. } } ) } Using a custom OkHttpClient \u00b6 Coil uses OkHttp for all its networking operations. You can specify a custom OkHttpClient when creating your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) // Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread. . okHttpClient { OkHttpClient . Builder () . addInterceptor ( CustomInterceptor ()) . build () } . build () Note If you already have a built OkHttpClient , use newBuilder() to build a new client that shares resources with the original. Headers \u00b6 Headers can be added to your image requests in one of two ways. You can set headers for a single request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . setHeader ( \"Cache-Control\" , \"no-cache\" ) . target ( imageView ) . build () imageLoader . execute ( request ) Or you can create an OkHttp Interceptor that sets headers for every request executed by your ImageLoader : class RequestHeaderInterceptor ( private val name : String , private val value : String ) : Interceptor { override fun intercept ( chain : Interceptor . Chain ): Response { val request = chain . request (). newBuilder () . header ( name , value ) . build () return chain . proceed ( request ) } } val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () // This header will be added to every image request. . addNetworkInterceptor ( RequestHeaderInterceptor ( \"Cache-Control\" , \"no-cache\" )) . build () } . build () Using a Memory Cache Key as a Placeholder \u00b6 Using a previous request's MemoryCache.Key as a placeholder for a subsequent request can be useful if the two images are the same, though loaded at different sizes. For instance, if the first request loads the image at 100x100 and the second request loads the image at 500x500, we can use the first image as a synchronous placeholder for the second request. Here's what this effect looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect. To achieve this effect, use the MemoryCache.Key of the first request as the ImageRequest.placeholderMemoryCacheKey of the second request. Here's an example: // First request listImageView . load ( \"https://www.example.com/image.jpg\" ) // Second request (once the first request finishes) detailImageView . load ( \"https://www.example.com/image.jpg\" ) { placeholderMemoryCacheKey ( listImageView . result . memoryCacheKey ) } Note Previous versions of Coil would attempt to set up this effect automatically . This required executing parts of the image pipeline synchronously on the main thread and it was ultimately removed in version 0.12.0 . Shared Element Transitions \u00b6 Shared element transitions allow you to animate between Activities and Fragments . Here are some recommendations on how to get them to work with Coil: Shared element transitions are incompatible with hardware bitmaps. You should set allowHardware(false) to disable hardware bitmaps for both the ImageView you are animating from and the view you are animating to. If you don't, the transition will throw an java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps exception. Use the MemoryCache.Key of the start image as the placeholderMemoryCacheKey for the end image. This ensures that the start image is used as the placeholder for the end image, which results in a smooth transition with no white flashes if the image is in the memory cache. Use ChangeImageTransform and ChangeBounds together for optimal results. Remote Views \u00b6 Coil does not provide a Target for RemoteViews out of the box, however you can create one like so: class RemoteViewsTarget ( private val context : Context , private val componentName : ComponentName , private val remoteViews : RemoteViews , @IdRes private val imageViewResId : Int ) : Target { override fun onStart ( placeholder : Drawable?) = setDrawable ( placeholder ) override fun onError ( error : Drawable?) = setDrawable ( error ) override fun onSuccess ( result : Drawable ) = setDrawable ( result ) private fun setDrawable ( drawable : Drawable?) { remoteViews . setImageViewBitmap ( imageViewResId , drawable ?. toBitmap ()) AppWidgetManager . getInstance ( context ). updateAppWidget ( componentName , remoteViews ) } } Then enqueue / execute the request like normal: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( RemoteViewsTarget ( context , componentName , remoteViews , imageViewResId )) . build () imageLoader . enqueue ( request ) Transforming Painters \u00b6 Both AsyncImage and AsyncImagePainter have placeholder / error / fallback arguments that accept Painter s. Painters are less flexible than using composables, but are faster as Coil doesn't need to use subcomposition. That said, it may be necessary to inset, stretch, tint, or transform your painter to get the desired UI. To accomplish this, copy this Gist into your project and wrap the painter like so: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null , placeholder = forwardingPainter ( painter = painterResource ( R . drawable . placeholder ), colorFilter = ColorFilter ( Color . Red ), alpha = 0.5f ) ) The onDraw can be overwritten using a trailing lambda: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null , placeholder = forwardingPainter ( painterResource ( R . drawable . placeholder )) { info -> inset ( 50f , 50f ) { with ( info . painter ) { draw ( size , info . alpha , info . colorFilter ) } } } )","title":"Recipes"},{"location":"recipes/#recipes","text":"This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fit your exact requirements, but it should hopefully give you a push in the right direction! See a common use case that isn't covered? Feel free to submit a PR with a new section.","title":"Recipes"},{"location":"recipes/#palette","text":"Palette allows you to extract prominent colors from an image. To create a Palette , you'll need access to an image's Bitmap . This can be done in a number of ways: You can get access to an image's bitmap by setting a ImageRequest.Listener and enqueuing an ImageRequest : imageView . load ( \"https://www.example.com/image.jpg\" ) { // Disable hardware bitmaps as Palette needs to read the image's pixels. allowHardware ( false ) listener ( onSuccess = { _ , result -> // Create the palette on a background thread. Palette . Builder ( result . drawable . toBitmap ()). generate { palette -> // Consume the palette. } } ) }","title":"Palette"},{"location":"recipes/#using-a-custom-okhttpclient","text":"Coil uses OkHttp for all its networking operations. You can specify a custom OkHttpClient when creating your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) // Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread. . okHttpClient { OkHttpClient . Builder () . addInterceptor ( CustomInterceptor ()) . build () } . build () Note If you already have a built OkHttpClient , use newBuilder() to build a new client that shares resources with the original.","title":"Using a custom OkHttpClient"},{"location":"recipes/#headers","text":"Headers can be added to your image requests in one of two ways. You can set headers for a single request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . setHeader ( \"Cache-Control\" , \"no-cache\" ) . target ( imageView ) . build () imageLoader . execute ( request ) Or you can create an OkHttp Interceptor that sets headers for every request executed by your ImageLoader : class RequestHeaderInterceptor ( private val name : String , private val value : String ) : Interceptor { override fun intercept ( chain : Interceptor . Chain ): Response { val request = chain . request (). newBuilder () . header ( name , value ) . build () return chain . proceed ( request ) } } val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () // This header will be added to every image request. . addNetworkInterceptor ( RequestHeaderInterceptor ( \"Cache-Control\" , \"no-cache\" )) . build () } . build ()","title":"Headers"},{"location":"recipes/#using-a-memory-cache-key-as-a-placeholder","text":"Using a previous request's MemoryCache.Key as a placeholder for a subsequent request can be useful if the two images are the same, though loaded at different sizes. For instance, if the first request loads the image at 100x100 and the second request loads the image at 500x500, we can use the first image as a synchronous placeholder for the second request. Here's what this effect looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect. To achieve this effect, use the MemoryCache.Key of the first request as the ImageRequest.placeholderMemoryCacheKey of the second request. Here's an example: // First request listImageView . load ( \"https://www.example.com/image.jpg\" ) // Second request (once the first request finishes) detailImageView . load ( \"https://www.example.com/image.jpg\" ) { placeholderMemoryCacheKey ( listImageView . result . memoryCacheKey ) } Note Previous versions of Coil would attempt to set up this effect automatically . This required executing parts of the image pipeline synchronously on the main thread and it was ultimately removed in version 0.12.0 .","title":"Using a Memory Cache Key as a Placeholder"},{"location":"recipes/#shared-element-transitions","text":"Shared element transitions allow you to animate between Activities and Fragments . Here are some recommendations on how to get them to work with Coil: Shared element transitions are incompatible with hardware bitmaps. You should set allowHardware(false) to disable hardware bitmaps for both the ImageView you are animating from and the view you are animating to. If you don't, the transition will throw an java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps exception. Use the MemoryCache.Key of the start image as the placeholderMemoryCacheKey for the end image. This ensures that the start image is used as the placeholder for the end image, which results in a smooth transition with no white flashes if the image is in the memory cache. Use ChangeImageTransform and ChangeBounds together for optimal results.","title":"Shared Element Transitions"},{"location":"recipes/#remote-views","text":"Coil does not provide a Target for RemoteViews out of the box, however you can create one like so: class RemoteViewsTarget ( private val context : Context , private val componentName : ComponentName , private val remoteViews : RemoteViews , @IdRes private val imageViewResId : Int ) : Target { override fun onStart ( placeholder : Drawable?) = setDrawable ( placeholder ) override fun onError ( error : Drawable?) = setDrawable ( error ) override fun onSuccess ( result : Drawable ) = setDrawable ( result ) private fun setDrawable ( drawable : Drawable?) { remoteViews . setImageViewBitmap ( imageViewResId , drawable ?. toBitmap ()) AppWidgetManager . getInstance ( context ). updateAppWidget ( componentName , remoteViews ) } } Then enqueue / execute the request like normal: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( RemoteViewsTarget ( context , componentName , remoteViews , imageViewResId )) . build () imageLoader . enqueue ( request )","title":"Remote Views"},{"location":"recipes/#transforming-painters","text":"Both AsyncImage and AsyncImagePainter have placeholder / error / fallback arguments that accept Painter s. Painters are less flexible than using composables, but are faster as Coil doesn't need to use subcomposition. That said, it may be necessary to inset, stretch, tint, or transform your painter to get the desired UI. To accomplish this, copy this Gist into your project and wrap the painter like so: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null , placeholder = forwardingPainter ( painter = painterResource ( R . drawable . placeholder ), colorFilter = ColorFilter ( Color . Red ), alpha = 0.5f ) ) The onDraw can be overwritten using a trailing lambda: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null , placeholder = forwardingPainter ( painterResource ( R . drawable . placeholder )) { info -> inset ( 50f , 50f ) { with ( info . painter ) { draw ( size , info . alpha , info . colorFilter ) } } } )","title":"Transforming Painters"},{"location":"svgs/","text":"SVGs \u00b6 To add SVG support, import the extension library: implementation ( \"io.coil-kt:coil-svg:2.2.2\" ) And add the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . components { add ( SvgDecoder . Factory ()) } . build () The ImageLoader will automatically detect and decode any SVGs. Coil detects SVGs by looking for the <svg marker in the first 1 KB of the file, which should cover most cases. If the SVG is not automatically detected, you can set the Decoder explicitly for the request: imageView . load ( \"/path/to/svg\" ) { decoderFactory { result , options , _ -> SvgDecoder ( result . source , options ) } }","title":"SVGs"},{"location":"svgs/#svgs","text":"To add SVG support, import the extension library: implementation ( \"io.coil-kt:coil-svg:2.2.2\" ) And add the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . components { add ( SvgDecoder . Factory ()) } . build () The ImageLoader will automatically detect and decode any SVGs. Coil detects SVGs by looking for the <svg marker in the first 1 KB of the file, which should cover most cases. If the SVG is not automatically detected, you can set the Decoder explicitly for the request: imageView . load ( \"/path/to/svg\" ) { decoderFactory { result , options , _ -> SvgDecoder ( result . source , options ) } }","title":"SVGs"},{"location":"targets/","text":"Targets \u00b6 Targets receive the Drawable result of an ImageRequest . They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a View (e.g. ImageViewTarget ). Here's the easiest way to create a custom target: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . enqueue ( request ) There are 2 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle.","title":"Targets"},{"location":"targets/#targets","text":"Targets receive the Drawable result of an ImageRequest . They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a View (e.g. ImageViewTarget ). Here's the easiest way to create a custom target: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . enqueue ( request ) There are 2 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle.","title":"Targets"},{"location":"transformations/","text":"Transformations \u00b6 Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 2 transformations: circle crop and rounded corners . Transformations only modify the pixel data for static images. Adding a transformation to an ImageRequest that produces an animated image will convert it to a static image so the transformation can be applied. To transform the pixel data of each frame of an animated image, see AnimatedTransformation . See the API documentation for more information. Note If the Drawable returned by the image pipeline is not a BitmapDrawable , it will be converted to one. This will cause animated drawables to only draw the first frame of their animation. This behaviour can be disabled by setting ImageRequest.Builder.allowConversionToBitmap(false) .","title":"Transformations"},{"location":"transformations/#transformations","text":"Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 2 transformations: circle crop and rounded corners . Transformations only modify the pixel data for static images. Adding a transformation to an ImageRequest that produces an animated image will convert it to a static image so the transformation can be applied. To transform the pixel data of each frame of an animated image, see AnimatedTransformation . See the API documentation for more information. Note If the Drawable returned by the image pipeline is not a BitmapDrawable , it will be converted to one. This will cause animated drawables to only draw the first frame of their animation. This behaviour can be disabled by setting ImageRequest.Builder.allowConversionToBitmap(false) .","title":"Transformations"},{"location":"transitions/","text":"Transitions \u00b6 Transitions allow you to animate setting the result of an image request on a Target . Both ImageLoader and ImageRequest builders accept a Transition.Factory . Transitions allow you to control how the success/error drawable is set on the Target . This allows you to animate the target's view or wrap the input drawable. By default, Coil comes packaged with 2 transitions: CrossfadeTransition.Factory which crossfades from the current drawable to the success/error drawable. Transition.Factory.NONE which sets the drawable on the Target immediately without animating. Take a look at the CrossfadeTransition source code for an example of how to write a custom Transition . See the API documentation for more information.","title":"Transitions"},{"location":"transitions/#transitions","text":"Transitions allow you to animate setting the result of an image request on a Target . Both ImageLoader and ImageRequest builders accept a Transition.Factory . Transitions allow you to control how the success/error drawable is set on the Target . This allows you to animate the target's view or wrap the input drawable. By default, Coil comes packaged with 2 transitions: CrossfadeTransition.Factory which crossfades from the current drawable to the success/error drawable. Transition.Factory.NONE which sets the drawable on the Target immediately without animating. Take a look at the CrossfadeTransition source code for an example of how to write a custom Transition . See the API documentation for more information.","title":"Transitions"},{"location":"upgrading/","text":"Upgrading from Coil 1.x to 2.x \u00b6 This is a short guide to highlight the main changes when upgrading from Coil 1.x to 2.x and how to handle them. This upgrade guide doesn't cover every binary or source incompatible change, but it does cover the most important changes. Minimum API 21 \u00b6 Coil 2.x requires minimum API 21. This is also the minimum API required for Jetpack Compose and OkHttp 4.x. ImageRequest default scale \u00b6 Coil 2.x changes ImageRequest 's default scale from Scale.FILL to Scale.FIT . This was done to be consistent with ImageView 's default ScaleType and Image 's default ContentScale . Scale is still autodetected if you set an ImageView as your ImageRequest.target . Size refactor \u00b6 Size 's width and height are now two Dimension s instead of Int pixel values. Dimension is either a pixel value or Dimension.Undefined , which represents an undefined/unbounded constraint. For example, if the size is Size(400, Dimension.Undefined) that means the image should be scaled to have 400 pixels for its width irrespective of its height. You can use the pxOrElse extension to get the pixel value (if present), else use a fallback: val width = size . width . pxOrElse { - 1 } if ( width > 0 ) { // Use the pixel value. } This change was made to improve support for cases where a target has one unbounded dimension (e.g. if one dimension is ViewGroup.LayoutParams.WRAP_CONTENT for a View or Constraints.Infinity in Compose). Jetpack Compose \u00b6 Coil 2.x significantly reworks the Jetpack Compose integration to add features, improve stability, and improve performance. In Coil 1.x you would use rememberImagePainter to load an image: val painter = rememberImagePainter ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) } Image ( painter = painter , contentDescription = null , contentScale = ContentScale . Crop ) In Coil 2.x rememberImagePainter has been changed to rememberAsyncImagePainter with the following changes: The trailing lambda argument to configure the ImageRequest has been removed. In Coil 2.x, rememberAsyncImagePainter defaults to using ContentScale.Fit to be consistent with Image whereas in Coil 1.x it would default to ContentScale.Crop . As such, if you set a custom ContentScale on Image , you now also need to pass it to rememberAsyncImagePainter . val painter = rememberAsyncImagePainter ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . build (), contentScale = ContentScale . Crop ) Image ( painter = painter , contentDescription = null , contentScale = ContentScale . Crop ) Additionally, Coil now has AsyncImage and SubcomposeAsyncImage composable functions, which add new features and work-around some design limitations of rememberAsyncImagePainter . Check out the full Jetpack Compose docs here . Disk Cache \u00b6 Coil 2.x has its own public disk cache class that can be accessed using imageLoader.diskCache . Coil 1.x relied on OkHttp's disk cache, however it's no longer needed. To configure the disk cache in 1.x you would use CoilUtils.createDefaultCache : ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder (). cache ( CoilUtils . createDefaultCache ( context )). build () } . build () In Coil 2.x you should not set a Cache object on your OkHttpClient when used with an ImageLoader . Instead configure the disk cache object like so: ImageLoader . Builder ( context ) . diskCache { DiskCache . Builder () . directory ( context . cacheDir . resolve ( \"image_cache\" )) . build () } . build () This change was made to add functionality and improve performance: Support thread interruption while decoding images. Thread interruption allows fast cancellation of decode operations. This is particularly important for quickly scrolling through a list. By using a custom disk cache Coil is able to ensure a network source is fully read to disk before decoding. This is necessary as writing the data to disk cannot be interrupted - only the decode step can be interrupted. OkHttp's Cache shouldn't be used with Coil 2.0 as it's not possible to guarantee that all data is written to disk before decoding. Avoid buffering/creating temporary files for decode APIs that don't support InputStream s or require direct access to a File (e.g. ImageDecoder , MediaMetadataRetriever ). Add a public read/write DiskCache API. In Coil 2.x Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. When upgrading from Coil 1.x to 2.x, any existing disk cache will be cleared as the internal format has changed. Image pipeline refactor \u00b6 Coil 2.x refactors the image pipeline classes to be more flexible. Here's a high-level list of the changes: Introduce a new class, Keyer , that computes the memory cache key for a request. It replaces Fetcher.key . Mapper , Keyer , Fetcher , and Decoder can return null to delegate to the next element in the list of components. Add Options to Mapper.map 's signature. Introduce Fetcher.Factory and Decoder.Factory . Use the factories to determine if a specific Fetcher / Decoder is applicable. Return null if that Fetcher / Decoder is not applicable. Remove bitmap pooling \u00b6 Coil 2.x removes bitmap pooling and its associated classes ( BitmapPool , PoolableViewTarget ). See here for why it was removed.","title":"Upgrading from Coil 1.x to 2.x"},{"location":"upgrading/#upgrading-from-coil-1x-to-2x","text":"This is a short guide to highlight the main changes when upgrading from Coil 1.x to 2.x and how to handle them. This upgrade guide doesn't cover every binary or source incompatible change, but it does cover the most important changes.","title":"Upgrading from Coil 1.x to 2.x"},{"location":"upgrading/#minimum-api-21","text":"Coil 2.x requires minimum API 21. This is also the minimum API required for Jetpack Compose and OkHttp 4.x.","title":"Minimum API 21"},{"location":"upgrading/#imagerequest-default-scale","text":"Coil 2.x changes ImageRequest 's default scale from Scale.FILL to Scale.FIT . This was done to be consistent with ImageView 's default ScaleType and Image 's default ContentScale . Scale is still autodetected if you set an ImageView as your ImageRequest.target .","title":"ImageRequest default scale"},{"location":"upgrading/#size-refactor","text":"Size 's width and height are now two Dimension s instead of Int pixel values. Dimension is either a pixel value or Dimension.Undefined , which represents an undefined/unbounded constraint. For example, if the size is Size(400, Dimension.Undefined) that means the image should be scaled to have 400 pixels for its width irrespective of its height. You can use the pxOrElse extension to get the pixel value (if present), else use a fallback: val width = size . width . pxOrElse { - 1 } if ( width > 0 ) { // Use the pixel value. } This change was made to improve support for cases where a target has one unbounded dimension (e.g. if one dimension is ViewGroup.LayoutParams.WRAP_CONTENT for a View or Constraints.Infinity in Compose).","title":"Size refactor"},{"location":"upgrading/#jetpack-compose","text":"Coil 2.x significantly reworks the Jetpack Compose integration to add features, improve stability, and improve performance. In Coil 1.x you would use rememberImagePainter to load an image: val painter = rememberImagePainter ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) } Image ( painter = painter , contentDescription = null , contentScale = ContentScale . Crop ) In Coil 2.x rememberImagePainter has been changed to rememberAsyncImagePainter with the following changes: The trailing lambda argument to configure the ImageRequest has been removed. In Coil 2.x, rememberAsyncImagePainter defaults to using ContentScale.Fit to be consistent with Image whereas in Coil 1.x it would default to ContentScale.Crop . As such, if you set a custom ContentScale on Image , you now also need to pass it to rememberAsyncImagePainter . val painter = rememberAsyncImagePainter ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . build (), contentScale = ContentScale . Crop ) Image ( painter = painter , contentDescription = null , contentScale = ContentScale . Crop ) Additionally, Coil now has AsyncImage and SubcomposeAsyncImage composable functions, which add new features and work-around some design limitations of rememberAsyncImagePainter . Check out the full Jetpack Compose docs here .","title":"Jetpack Compose"},{"location":"upgrading/#disk-cache","text":"Coil 2.x has its own public disk cache class that can be accessed using imageLoader.diskCache . Coil 1.x relied on OkHttp's disk cache, however it's no longer needed. To configure the disk cache in 1.x you would use CoilUtils.createDefaultCache : ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder (). cache ( CoilUtils . createDefaultCache ( context )). build () } . build () In Coil 2.x you should not set a Cache object on your OkHttpClient when used with an ImageLoader . Instead configure the disk cache object like so: ImageLoader . Builder ( context ) . diskCache { DiskCache . Builder () . directory ( context . cacheDir . resolve ( \"image_cache\" )) . build () } . build () This change was made to add functionality and improve performance: Support thread interruption while decoding images. Thread interruption allows fast cancellation of decode operations. This is particularly important for quickly scrolling through a list. By using a custom disk cache Coil is able to ensure a network source is fully read to disk before decoding. This is necessary as writing the data to disk cannot be interrupted - only the decode step can be interrupted. OkHttp's Cache shouldn't be used with Coil 2.0 as it's not possible to guarantee that all data is written to disk before decoding. Avoid buffering/creating temporary files for decode APIs that don't support InputStream s or require direct access to a File (e.g. ImageDecoder , MediaMetadataRetriever ). Add a public read/write DiskCache API. In Coil 2.x Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. When upgrading from Coil 1.x to 2.x, any existing disk cache will be cleared as the internal format has changed.","title":"Disk Cache"},{"location":"upgrading/#image-pipeline-refactor","text":"Coil 2.x refactors the image pipeline classes to be more flexible. Here's a high-level list of the changes: Introduce a new class, Keyer , that computes the memory cache key for a request. It replaces Fetcher.key . Mapper , Keyer , Fetcher , and Decoder can return null to delegate to the next element in the list of components. Add Options to Mapper.map 's signature. Introduce Fetcher.Factory and Decoder.Factory . Use the factories to determine if a specific Fetcher / Decoder is applicable. Return null if that Fetcher / Decoder is not applicable.","title":"Image pipeline refactor"},{"location":"upgrading/#remove-bitmap-pooling","text":"Coil 2.x removes bitmap pooling and its associated classes ( BitmapPool , PoolableViewTarget ). See here for why it was removed.","title":"Remove bitmap pooling"},{"location":"videos/","text":"Video Frames \u00b6 To add video frame support, import the extension library: implementation ( \"io.coil-kt:coil-video:2.2.2\" ) And add the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . components { add ( VideoFrameDecoder . Factory ()) } . build () To specify the time code of the frame to extract from a video, use videoFrameMillis or videoFrameMicros : imageView . load ( \"/path/to/video.mp4\" ) { videoFrameMillis ( 1000 ) } If a frame time isn't specified, the first frame of the video is decoded. The ImageLoader will automatically detect any videos and extract their frames if the request's filename/URI ends with a valid video extension . If it does not, you can set the Decoder explicitly for the request: imageView . load ( \"/path/to/video\" ) { decoderFactory { result , options , _ -> VideoFrameDecoder ( result . source , options ) } }","title":"Video Frames"},{"location":"videos/#video-frames","text":"To add video frame support, import the extension library: implementation ( \"io.coil-kt:coil-video:2.2.2\" ) And add the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . components { add ( VideoFrameDecoder . Factory ()) } . build () To specify the time code of the frame to extract from a video, use videoFrameMillis or videoFrameMicros : imageView . load ( \"/path/to/video.mp4\" ) { videoFrameMillis ( 1000 ) } If a frame time isn't specified, the first frame of the video is decoded. The ImageLoader will automatically detect any videos and extract their frames if the request's filename/URI ends with a valid video extension . If it does not, you can set the Decoder explicitly for the request: imageView . load ( \"/path/to/video\" ) { decoderFactory { result , options , _ -> VideoFrameDecoder ( result . source , options ) } }","title":"Video Frames"}]}
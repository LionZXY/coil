{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"faq/","title":"FAQ","text":"<p>Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search Github discussions.</p>"},{"location":"faq/#can-coil-be-used-with-java-projects-or-mixed-kotlinjava-projects","title":"Can Coil be used with Java projects or mixed Kotlin/Java projects?","text":"<p>Yes! Read here.</p>"},{"location":"faq/#how-do-i-preload-an-image","title":"How do I preload an image?","text":"<p>Read here.</p>"},{"location":"faq/#how-do-i-enable-logging","title":"How do I enable logging?","text":"<p>Set <code>logger(DebugLogger())</code> when constructing your <code>ImageLoader</code>.</p> <p>Note</p> <p><code>DebugLogger</code> should only be used in debug builds.</p>"},{"location":"faq/#how-do-i-target-java-8","title":"How do I target Java 8?","text":"<p>Coil requires Java 8 bytecode. This is enabled by default on the Android Gradle Plugin <code>4.2.0</code> and later and the Kotlin Gradle Plugin <code>1.5.0</code> and later. If you're using older versions of those plugins add the following to your Gradle build script:</p> <p>Gradle (<code>.gradle</code>):</p> <pre><code>android {\ncompileOptions {\nsourceCompatibility JavaVersion.VERSION_1_8\ntargetCompatibility JavaVersion.VERSION_1_8\n}\nkotlinOptions {\njvmTarget = \"1.8\"\n}\n}\n</code></pre> <p>Gradle Kotlin DSL (<code>.gradle.kts</code>):</p> <pre><code>android {\ncompileOptions {\nsourceCompatibility = JavaVersion.VERSION_1_8\ntargetCompatibility = JavaVersion.VERSION_1_8\n}\nkotlinOptions {\njvmTarget = \"1.8\"\n}\n}\n</code></pre>"},{"location":"faq/#how-do-i-get-development-snapshots","title":"How do I get development snapshots?","text":"<p>Add the snapshots repository to your list of repositories:</p> <p>Gradle (<code>.gradle</code>):</p> <pre><code>allprojects {\nrepositories {\nmaven { url 'https://oss.sonatype.org/content/repositories/snapshots' }\n}\n}\n</code></pre> <p>Gradle Kotlin DSL (<code>.gradle.kts</code>):</p> <pre><code>allprojects {\nrepositories {\nmaven(\"https://oss.sonatype.org/content/repositories/snapshots\")\n}\n}\n</code></pre> <p>Then depend on the same artifacts with the latest snapshot version.</p> <p>Note</p> <p>Snapshots are deployed for each new commit on <code>main</code> that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#artifacts","title":"Artifacts","text":"<p>Coil has 8 artifacts published to <code>mavenCentral()</code>:</p> <ul> <li><code>io.coil-kt:coil</code>: The default artifact which depends on <code>io.coil-kt:coil-base</code>, creates a singleton <code>ImageLoader</code>, and includes the <code>ImageView</code> extension functions.</li> <li><code>io.coil-kt:coil-base</code>: A subset of <code>io.coil-kt:coil</code> which does not include the singleton <code>ImageLoader</code> and the <code>ImageView</code> extension functions.</li> <li><code>io.coil-kt:coil-compose</code>: Includes support for Jetpack Compose.</li> <li><code>io.coil-kt:coil-compose-base</code>: A subset of <code>io.coil-kt:coil-compose</code> which does not include functions that depend on the singleton <code>ImageLoader</code>.</li> <li><code>io.coil-kt:coil-gif</code>: Includes two decoders to support decoding GIFs. See GIFs for more details.</li> <li><code>io.coil-kt:coil-svg</code>: Includes a decoder to support decoding SVGs. See SVGs for more details.</li> <li><code>io.coil-kt:coil-video</code>: Includes a decoder to support decoding frames from any of Android's supported video formats. See videos for more details.</li> <li><code>io.coil-kt:coil-bom</code>: Includes a bill of materials. Importing <code>coil-bom</code> allows you to depend on other Coil artifacts without specifying a version.</li> </ul>"},{"location":"getting_started/#image-loaders","title":"Image Loaders","text":"<p><code>ImageLoader</code>s are service classes that execute <code>ImageRequest</code>s. <code>ImageLoader</code>s handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more.</p> <p>The default Coil artifact (<code>io.coil-kt:coil</code>) includes the singleton <code>ImageLoader</code>, which can be accessed using an extension function: <code>context.imageLoader</code>.</p> <p>The singleton <code>ImageLoader</code> can be configured by implementing <code>ImageLoaderFactory</code> on your <code>Application</code> class:</p> <pre><code>class MyApplication : Application(), ImageLoaderFactory {\noverride fun newImageLoader(): ImageLoader {\nreturn ImageLoader.Builder(this)\n.crossfade(true)\n.build()\n}\n}\n</code></pre> <p>Implementing <code>ImageLoaderFactory</code> is optional. If you don't, Coil will lazily create an <code>ImageLoader</code> with the default values.</p> <p>Check out the full documentation for more info.</p>"},{"location":"getting_started/#image-requests","title":"Image Requests","text":"<p><code>ImageRequest</code>s are value classes that are executed by <code>ImageLoader</code>s. They describe where an image should be loaded from, how it should be loaded, and any extra parameters. An <code>ImageLoader</code> has two methods that can execute a request:</p> <ul> <li><code>enqueue</code>: Enqueues the <code>ImageRequest</code> to be executed asynchronously on a background thread.</li> <li><code>execute</code>: Executes the <code>ImageRequest</code> in the current coroutine and returns an <code>ImageResult</code>.</li> </ul> <p>All requests should set <code>data</code> (i.e. url, uri, file, drawable resource, etc.). This is what the <code>ImageLoader</code> will use to decide where to fetch the image data from. If you do not set <code>data</code>, it will default to <code>NullRequestData</code>.</p> <p>Additionally, you likely want to set a <code>target</code> when enqueuing a request. It's optional, but the <code>target</code> is what will receive the loaded placeholder/success/error drawables. Executed requests return an <code>ImageResult</code> which has the success/error drawable.</p> <p>Here's an example:</p> <pre><code>// enqueue\nval request = ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.target(imageView)\n.build()\nval disposable = imageLoader.enqueue(request)\n// execute\nval request = ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.build()\nval result = imageLoader.execute(request)\n</code></pre>"},{"location":"getting_started/#imageview-extension-functions","title":"ImageView Extension Functions","text":"<p>The <code>io.coil-kt:coil</code> artifact provides a set of <code>ImageView</code> extension functions. Here's an example for loading a URL into an <code>ImageView</code>:</p> <pre><code>imageView.load(\"https://www.example.com/image.jpg\")\n</code></pre> <p>The above call is equivalent to:</p> <pre><code>val imageLoader = imageView.context.imageLoader\nval request = ImageRequest.Builder(imageView.context)\n.data(\"https://www.example.com/image.jpg\")\n.target(imageView)\n.build()\nimageLoader.enqueue(request)\n</code></pre> <p><code>ImageView.load</code> calls can be configured with an optional trailing lambda parameter:</p> <pre><code>imageView.load(\"https://www.example.com/image.jpg\") {\ncrossfade(true)\nplaceholder(R.drawable.image)\ntransformations(CircleCropTransformation())\n}\n</code></pre> <p>See the docs here for more information.</p>"},{"location":"getting_started/#supported-data-types","title":"Supported Data Types","text":"<p>The base data types that are supported by all <code>ImageLoader</code> instances are:</p> <ul> <li>String (mapped to a Uri)</li> <li>HttpUrl</li> <li>Uri (<code>android.resource</code>, <code>content</code>, <code>file</code>, <code>http</code>, and <code>https</code> schemes)</li> <li>File</li> <li>@DrawableRes Int</li> <li>Drawable</li> <li>Bitmap</li> <li>ByteArray</li> <li>ByteBuffer</li> </ul>"},{"location":"getting_started/#supported-image-formats","title":"Supported Image Formats","text":"<p>All <code>ImageLoader</code>s support the following non-animated file types:</p> <ul> <li>BMP</li> <li>JPEG</li> <li>PNG</li> <li>WebP</li> <li>HEIF (Android 8.0+)</li> </ul> <p>Additionally, Coil has extension libraries for the following file types:</p> <ul> <li><code>coil-gif</code>: GIF, animated WebP (Android 9.0+), animated HEIF (Android 11.0+)</li> <li><code>coil-svg</code>: SVG</li> <li><code>coil-video</code>: Static video frames from any video codec supported by Android</li> </ul>"},{"location":"getting_started/#preloading","title":"Preloading","text":"<p>To preload an image into memory, enqueue or execute an <code>ImageRequest</code> without a <code>Target</code>:</p> <pre><code>val request = ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n// Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at.\n.size(ViewSizeResolver(imageView))\n.build()\nimageLoader.enqueue(request)\n</code></pre> <p>To preload a network image only into the disk cache, disable the memory cache for the request:</p> <pre><code>val request = ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.memoryCachePolicy(CachePolicy.DISABLED)\n.build()\nimageLoader.enqueue(request)\n</code></pre>"},{"location":"getting_started/#cancelling-requests","title":"Cancelling Requests","text":"<p><code>ImageRequest</code>s will be automatically cancelled in the following cases:</p> <ul> <li><code>request.lifecycle</code> reaches the <code>DESTROYED</code> state.</li> <li><code>request.target</code> is a <code>ViewTarget</code> and its <code>View</code> is detached.</li> </ul> <p>Additionally, <code>ImageLoader.enqueue</code> returns a Disposable, which can be used to dispose the request (which cancels it and frees its associated resources):</p> <pre><code>val disposable = imageView.load(\"https://www.example.com/image.jpg\")\n// Cancel the request.\ndisposable.dispose()\n</code></pre>"},{"location":"image_loaders/","title":"Image Loaders","text":"<p><code>ImageLoader</code>s are service objects that execute <code>ImageRequest</code>s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n.crossfade(true)\n.build()\n</code></pre> <p>Coil performs best when you create a single <code>ImageLoader</code> and share it throughout your app. This is because each <code>ImageLoader</code> has its own memory cache, disk cache, and <code>OkHttpClient</code>.</p>"},{"location":"image_loaders/#caching","title":"Caching","text":"<p>Each <code>ImageLoader</code> keeps a memory cache of recently decoded <code>Bitmap</code>s as well as a disk cache for any images loaded from the Internet. Both can be configured when creating an <code>ImageLoader</code>:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n.memoryCache {\nMemoryCache.Builder(context)\n.maxSizePercent(0.25)\n.build()\n}\n.diskCache {\nDiskCache.Builder()\n.directory(context.cacheDir.resolve(\"image_cache\"))\n.maxSizePercent(0.02)\n.build()\n}\n.build()\n</code></pre> <p>You can access items in the memory and disk caches using their keys, which are returned in an <code>ImageResult</code> after an image is loaded. The <code>ImageResult</code> is returned by <code>ImageLoader.execute</code> or in <code>ImageRequest.Listener.onSuccess</code> and <code>ImageRequest.Listener.onError</code>.</p> <p>Note</p> <p>Coil 1.x relied on OkHttp's disk cache. Coil 2.x has its own disk cache and should not use OkHttp's <code>Cache</code>.</p>"},{"location":"image_loaders/#singleton-vs-dependency-injection","title":"Singleton vs. Dependency Injection","text":"<p>The default Coil artifact (<code>io.coil-kt:coil</code>) includes the singleton <code>ImageLoader</code>, which can be accessed using an extension function: <code>context.imageLoader</code>.</p> <p>Coil performs best when you have a single <code>ImageLoader</code> that's shared throughout your app. This is because each <code>ImageLoader</code> has its own set of resources.</p> <p>The singleton <code>ImageLoader</code> can be configured by implementing <code>ImageLoaderFactory</code> on your <code>Application</code> class.</p> <p>Optionally, you can create your own <code>ImageLoader</code> instance(s) and inject them using a dependency injector like Dagger. If you do that, depend on <code>io.coil-kt:coil-base</code> as that artifact doesn't create the singleton <code>ImageLoader</code>.</p>"},{"location":"image_loaders/#testing","title":"Testing","text":"<p><code>ImageLoader</code> is an interface, which you can replace with a fake implementation.</p> <p>For instance, you could create a fake <code>ImageLoader</code> implementation which always returns the same <code>Drawable</code> synchronously:</p> <pre><code>class FakeImageLoader(private val context: Context) : ImageLoader {\noverride val defaults = DefaultRequestOptions()\noverride val components = ComponentRegistry()\noverride val memoryCache: MemoryCache? get() = null\noverride val diskCache: DiskCache? get() = null\noverride fun enqueue(request: ImageRequest): Disposable {\n// Always call onStart before onSuccess.\nrequest.target?.onStart(request.placeholder)\nval result = ColorDrawable(Color.BLACK)\nrequest.target?.onSuccess(result)\nreturn object : Disposable {\noverride val job = CompletableDeferred(newResult(request, result))\noverride val isDisposed get() = true\noverride fun dispose() {}\n}\n}\noverride suspend fun execute(request: ImageRequest): ImageResult {\nreturn newResult(request, ColorDrawable(Color.BLACK))\n}\nprivate fun newResult(request: ImageRequest, drawable: Drawable): SuccessResult {\nreturn SuccessResult(\ndrawable = drawable,\nrequest = request,\ndataSource = DataSource.MEMORY_CACHE\n)\n}\noverride fun newBuilder() = throw UnsupportedOperationException()\noverride fun shutdown() {}\n}\n</code></pre> <p>This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.</p>"},{"location":"image_pipeline/","title":"Extending the Image Pipeline","text":"<p>Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, MP4, etc.)</p> <p>Fortunately, ImageLoaders support pluggable components to add new cache layers, new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of five main parts that are executed in the following order: Interceptors, Mappers, Keyers, Fetchers, and Decoders.</p> <p>Custom components must be added to the <code>ImageLoader</code> when constructing it through its ComponentRegistry:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n.components {\nadd(CustomCacheInterceptor())\nadd(ItemMapper())\nadd(HttpUrlKeyer())\nadd(CronetFetcher.Factory())\nadd(GifDecoder.Factory())\n}\n.build()\n</code></pre>"},{"location":"image_pipeline/#interceptors","title":"Interceptors","text":"<p>Interceptors allow you to observe, transform, short circuit, or retry requests to an <code>ImageLoader</code>'s image engine. For example, you can add a custom cache layer like so:</p> <pre><code>class CustomCacheInterceptor(\nprivate val context: Context,\nprivate val cache: LruCache&lt;String, Drawable&gt;\n) : Interceptor {\noverride suspend fun intercept(chain: Interceptor.Chain): ImageResult {\nval value = cache.get(chain.request.data.toString())\nif (value != null) {\nreturn SuccessResult(\ndrawable = value.bitmap.toDrawable(context),\nrequest = chain.request,\ndataSource = DataSource.MEMORY_CACHE\n)\n}\nreturn chain.proceed(chain.request)\n}\n}\n</code></pre> <p>Interceptors are an advanced feature that let you wrap an <code>ImageLoader</code>'s image pipeline with custom logic. Their design is heavily based on OkHttp's <code>Interceptor</code> interface.</p> <p>See Interceptor for more information.</p>"},{"location":"image_pipeline/#mappers","title":"Mappers","text":"<p>Mappers allow you to add support for custom data types. For instance, say we get this model from our server:</p> <pre><code>data class Item(\nval id: Int,\nval imageUrl: String,\nval price: Int,\nval weight: Double\n)\n</code></pre> <p>We could write a custom mapper to map it to its URL, which will be handled later in the pipeline:</p> <pre><code>class ItemMapper : Mapper&lt;Item, String&gt; {\noverride fun map(data: Item, options: Options) = data.imageUrl\n}\n</code></pre> <p>After registering it when building our <code>ImageLoader</code> (see above), we can safely load an <code>Item</code>:</p> <pre><code>val request = ImageRequest.Builder(context)\n.data(item)\n.target(imageView)\n.build()\nimageLoader.enqueue(request)\n</code></pre> <p>See Mapper for more information.</p>"},{"location":"image_pipeline/#keyers","title":"Keyers","text":"<p>Keyers convert data into a portion of a cache key. This value is used as <code>MemoryCache.Key.key</code> when/if this request's output is written to the <code>MemoryCache</code>.</p> <p>See Keyers for more information.</p>"},{"location":"image_pipeline/#fetchers","title":"Fetchers","text":"<p>Fetchers translate data (e.g. URL, URI, File, etc.) into either an <code>ImageSource</code> or a <code>Drawable</code>. They typically convert the input data into a format that can then be consumed by a <code>Decoder</code>. Use this interface to add support for custom fetching mechanisms (e.g. Cronet, custom URI schemes, etc.)</p> <p>See Fetcher for more information.</p>"},{"location":"image_pipeline/#decoders","title":"Decoders","text":"<p>Decoders read an <code>ImageSource</code> and return a <code>Drawable</code>. Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.).</p> <p>See Decoder for more information.</p>"},{"location":"image_requests/","title":"Image Requests","text":"<p><code>ImageRequest</code>s are value objects that provide all the necessary information for an ImageLoader to load an image.</p> <p><code>ImageRequest</code>s can be created using a builder:</p> <pre><code>val request = ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.crossfade(true)\n.target(imageView)\n.build()\n</code></pre> <p>Once you've created a request pass it to an <code>ImageLoader</code> to enqueue/execute it:</p> <pre><code>imageLoader.enqueue(request)\n</code></pre> <p>See the API documentation for more information.</p>"},{"location":"java_compatibility/","title":"Java Compatibility","text":"<p>Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java.</p> <p>Importantly, suspend functions cannot be implemented in Java. This means custom Transformations, Size Resolvers, Fetchers, and Decoders must be implemented in Kotlin.</p> <p>Despite these limitations, most of Coil's API is Java compatible. The <code>Context.imageLoader</code> extension function should not be used from Java. Instead, you can get the singleton <code>ImageLoader</code> using:</p> <pre><code>ImageLoader imageLoader = Coil.imageLoader(context)\n</code></pre> <p>The syntax to enqueue an <code>ImageRequest</code> is almost the same in Java and Kotlin:</p> <pre><code>ImageRequest request = new ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.crossfade(true)\n.target(imageView)\n.build();\nimageLoader.enqueue(request)\n</code></pre> <p>Note</p> <p><code>ImageView.load</code> cannot be used from Java. Use the <code>ImageRequest.Builder</code> API instead.</p> <p><code>suspend</code> functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to use the <code>ImageLoader.executeBlocking</code> extension function which can be called from Java like so:</p> <pre><code>ImageRequest request = new ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.size(1080, 1920)\n.build();\nDrawable drawable = ImageLoaders.executeBlocking(imageLoader, request).getDrawable();\n</code></pre> <p>Note</p> <p><code>ImageLoaders.executeBlocking</code> will block the current thread instead of suspending. Do not call this from the main thread.</p>"},{"location":"migrating/","title":"Migrating from Glide/Picasso","text":"<p>Here are a few examples of how to migrate Glide/Picasso calls into Coil calls:</p>"},{"location":"migrating/#basic-usage","title":"Basic Usage","text":"<pre><code>// Glide\nGlide.with(context)\n.load(url)\n.into(imageView)\n// Picasso\nPicasso.get()\n.load(url)\n.into(imageView)\n// Coil\nimageView.load(url)\n</code></pre>"},{"location":"migrating/#custom-requests","title":"Custom Requests","text":"<pre><code>imageView.scaleType = ImageView.ScaleType.FIT_CENTER\n// Glide\nGlide.with(context)\n.load(url)\n.placeholder(placeholder)\n.fitCenter()\n.into(imageView)\n// Picasso\nPicasso.get()\n.load(url)\n.placeholder(placeholder)\n.fit()\n.into(imageView)\n// Coil (automatically detects the scale type)\nimageView.load(url) {\nplaceholder(placeholder)\n}\n</code></pre>"},{"location":"migrating/#non-view-targets","title":"Non-View Targets","text":"<pre><code>// Glide (has optional callbacks for start and error)\nGlide.with(context)\n.load(url)\n.into(object : CustomTarget&lt;Drawable&gt;() {\noverride fun onResourceReady(resource: Drawable, transition: Transition&lt;Drawable&gt;) {\n// Handle the successful result.\n}\noverride fun onLoadCleared(placeholder: Drawable) {\n// Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain.\n}\n})\n// Picasso\nPicasso.get()\n.load(url)\n.into(object : BitmapTarget {\noverride fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) {\n// Handle the successful result.\n}\noverride fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) {\n// Handle the error drawable.\n}\noverride fun onPrepareLoad(placeHolderDrawable: Drawable?) {\n// Handle the placeholder drawable.\n}\n})\n// Coil\nval request = ImageRequest.Builder(context)\n.data(url)\n.target(\nonStart = { placeholder -&gt;\n// Handle the placeholder drawable.\n},\nonSuccess = { result -&gt;\n// Handle the successful result.\n},\nonError = { error -&gt;\n// Handle the error drawable.\n}\n)\n.build()\ncontext.imageLoader.enqueue(request)\n</code></pre>"},{"location":"migrating/#background-thread","title":"Background Thread","text":"<pre><code>// Glide (blocks the current thread; must not be called from the main thread)\nval drawable = Glide.with(context)\n.load(url)\n.submit(width, height)\n.get()\n// Picasso (blocks the current thread; must not be called from the main thread)\nval drawable = Picasso.get()\n.load(url)\n.resize(width, height)\n.get()\n// Coil (suspends the current coroutine; non-blocking and thread safe)\nval request = ImageRequest.Builder(context)\n.data(url)\n.size(width, height)\n.build()\nval drawable = context.imageLoader.execute(request).drawable\n</code></pre>"},{"location":"recipes/","title":"Recipes","text":"<p>This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fit your exact requirements, but it should hopefully give you a push in the right direction!</p> <p>See a common use case that isn't covered? Feel free to submit a PR with a new section.</p>"},{"location":"recipes/#palette","title":"Palette","text":"<p>Palette allows you to extract prominent colors from an image. To create a <code>Palette</code>, you'll need access to an image's <code>Bitmap</code>. This can be done in a number of ways:</p> <p>You can get access to an image's bitmap by setting a <code>ImageRequest.Listener</code> and enqueuing an <code>ImageRequest</code>:</p> <pre><code>imageView.load(\"https://www.example.com/image.jpg\") {\n// Disable hardware bitmaps as Palette needs to read the image's pixels.\nallowHardware(false)\nlistener(\nonSuccess = { _, result -&gt;\n// Create the palette on a background thread.\nPalette.Builder(result.drawable.toBitmap()).generate { palette -&gt;\n// Consume the palette.\n}\n}\n)\n}\n</code></pre>"},{"location":"recipes/#using-a-custom-okhttpclient","title":"Using a custom OkHttpClient","text":"<p>Coil uses OkHttp for all its networking operations. You can specify a custom <code>OkHttpClient</code> when creating your <code>ImageLoader</code>:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n// Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread.\n.okHttpClient {\nOkHttpClient.Builder()\n.addInterceptor(CustomInterceptor())\n.build()\n}\n.build()\n</code></pre> <p>Note</p> <p>If you already have a built <code>OkHttpClient</code>, use <code>newBuilder()</code> to build a new client that shares resources with the original.</p>"},{"location":"recipes/#headers","title":"Headers","text":"<p>Headers can be added to your image requests in one of two ways. You can set headers for a single request:</p> <pre><code>val request = ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.setHeader(\"Cache-Control\", \"no-cache\")\n.target(imageView)\n.build()\nimageLoader.execute(request)\n</code></pre> <p>Or you can create an OkHttp <code>Interceptor</code> that sets headers for every request executed by your <code>ImageLoader</code>:</p> <pre><code>class RequestHeaderInterceptor(\nprivate val name: String,\nprivate val value: String\n) : Interceptor {\noverride fun intercept(chain: Interceptor.Chain): Response {\nval request = chain.request().newBuilder()\n.header(name, value)\n.build()\nreturn chain.proceed(request)\n}\n}\nval imageLoader = ImageLoader.Builder(context)\n.okHttpClient {\nOkHttpClient.Builder()\n// This header will be added to every image request.\n.addNetworkInterceptor(RequestHeaderInterceptor(\"Cache-Control\", \"no-cache\"))\n.build()\n}\n.build()\n</code></pre>"},{"location":"recipes/#using-a-memory-cache-key-as-a-placeholder","title":"Using a Memory Cache Key as a Placeholder","text":"<p>Using a previous request's <code>MemoryCache.Key</code> as a placeholder for a subsequent request can be useful if the two images are the same, though loaded at different sizes. For instance, if the first request loads the image at 100x100 and the second request loads the image at 500x500, we can use the first image as a synchronous placeholder for the second request.</p> <p>Here's what this effect looks like in the sample app:</p> <p> </p> <p>Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect.</p> <p>To achieve this effect, use the <code>MemoryCache.Key</code> of the first request as the <code>ImageRequest.placeholderMemoryCacheKey</code> of the second request. Here's an example:</p> <pre><code>// First request\nlistImageView.load(\"https://www.example.com/image.jpg\")\n// Second request (once the first request finishes)\ndetailImageView.load(\"https://www.example.com/image.jpg\") {\nplaceholderMemoryCacheKey(listImageView.result.memoryCacheKey)\n}\n</code></pre> <p>Note</p> <p>Previous versions of Coil would attempt to set up this effect automatically. This required executing parts of the image pipeline synchronously on the main thread and it was ultimately removed in version <code>0.12.0</code>.</p>"},{"location":"recipes/#shared-element-transitions","title":"Shared Element Transitions","text":"<p>Shared element transitions allow you to animate between <code>Activities</code> and <code>Fragments</code>. Here are some recommendations on how to get them to work with Coil:</p> <ul> <li> <p>Shared element transitions are incompatible with hardware bitmaps. You should set <code>allowHardware(false)</code> to disable hardware bitmaps for both the <code>ImageView</code> you are animating from and the view you are animating to. If you don't, the transition will throw an <code>java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps</code> exception.</p> </li> <li> <p>Use the <code>MemoryCache.Key</code> of the start image as the <code>placeholderMemoryCacheKey</code> for the end image. This ensures that the start image is used as the placeholder for the end image, which results in a smooth transition with no white flashes if the image is in the memory cache.</p> </li> <li> <p>Use <code>ChangeImageTransform</code> and <code>ChangeBounds</code> together for optimal results.</p> </li> </ul>"},{"location":"recipes/#remote-views","title":"Remote Views","text":"<p>Coil does not provide a <code>Target</code> for <code>RemoteViews</code> out of the box, however you can create one like so:</p> <pre><code>class RemoteViewsTarget(\nprivate val context: Context,\nprivate val componentName: ComponentName,\nprivate val remoteViews: RemoteViews,\n@IdRes private val imageViewResId: Int\n) : Target {\noverride fun onStart(placeholder: Drawable?) = setDrawable(placeholder)\noverride fun onError(error: Drawable?) = setDrawable(error)\noverride fun onSuccess(result: Drawable) = setDrawable(result)\nprivate fun setDrawable(drawable: Drawable?) {\nremoteViews.setImageViewBitmap(imageViewResId, drawable?.toBitmap())\nAppWidgetManager.getInstance(context).updateAppWidget(componentName, remoteViews)\n}\n}\n</code></pre> <p>Then <code>enqueue</code>/<code>execute</code> the request like normal:</p> <pre><code>val request = ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.target(RemoteViewsTarget(context, componentName, remoteViews, imageViewResId))\n.build()\nimageLoader.enqueue(request)\n</code></pre>"},{"location":"recipes/#transforming-painters","title":"Transforming Painters","text":"<p>Both <code>AsyncImage</code> and <code>AsyncImagePainter</code> have <code>placeholder</code>/<code>error</code>/<code>fallback</code> arguments that accept <code>Painter</code>s. Painters are less flexible than using composables, but are faster as Coil doesn't need to use subcomposition. That said, it may be necessary to inset, stretch, tint, or transform your painter to get the desired UI. To accomplish this, copy this Gist into your project and wrap the painter like so:</p> <pre><code>AsyncImage(\nmodel = \"https://example.com/image.jpg\",\ncontentDescription = null,\nplaceholder = forwardingPainter(\npainter = painterResource(R.drawable.placeholder),\ncolorFilter = ColorFilter(Color.Red),\nalpha = 0.5f\n)\n)\n</code></pre> <p>The <code>onDraw</code> can be overwritten using a trailing lambda:</p> <pre><code>AsyncImage(\nmodel = \"https://example.com/image.jpg\",\ncontentDescription = null,\nplaceholder = forwardingPainter(painterResource(R.drawable.placeholder)) { info -&gt;\ninset(50f, 50f) {\nwith(info.painter) {\ndraw(size, info.alpha, info.colorFilter)\n}\n}\n}\n)\n</code></pre>"},{"location":"targets/","title":"Targets","text":"<p>Targets receive the <code>Drawable</code> result of an <code>ImageRequest</code>. They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a <code>View</code> (e.g. <code>ImageViewTarget</code>).</p> <p>Here's the easiest way to create a custom target:</p> <pre><code>val request = ImageRequest.Builder(context)\n.data(\"https://www.example.com/image.jpg\")\n.target(\nonStart = { placeholder -&gt;\n// Handle the placeholder drawable.\n},\nonSuccess = { result -&gt;\n// Handle the successful result.\n},\nonError = { error -&gt;\n// Handle the error drawable.\n}\n)\n.build()\nimageLoader.enqueue(request)\n</code></pre> <p>There are 2 types of targets:</p> <ul> <li>Target: The base target class. Prefer this if the image request isn't tied to a <code>View</code>.</li> <li>ViewTarget: A target with an associated <code>View</code>. Prefer this if the request sets the placeholder/error/success Drawables on a <code>View</code>. Using <code>ViewTarget</code> also binds the request to the <code>View</code>'s lifecycle.</li> </ul>"},{"location":"transformations/","title":"Transformations","text":"<p>Transformations allow you to modify the pixel data of an image before the <code>Drawable</code> is returned from the request.</p> <p>By default, Coil comes packaged with 2 transformations: circle crop and rounded corners.</p> <p>Transformations only modify the pixel data for static images. Adding a transformation to an <code>ImageRequest</code> that produces an animated image will convert it to a static image so the transformation can be applied. To transform the pixel data of each frame of an animated image, see AnimatedTransformation.</p> <p>Custom transformations should implement <code>equals</code> and <code>hashCode</code> to ensure that two <code>ImageRequest</code>s with the same properties and using the same transformation are equal.</p> <p>See the API documentation for more information.</p> <p>Note</p> <p>If the <code>Drawable</code> returned by the image pipeline is not a <code>BitmapDrawable</code>, it will be converted to one. This will cause animated drawables to only draw the first frame of their animation. This behaviour can be disabled by setting <code>ImageRequest.Builder.allowConversionToBitmap(false)</code>.</p>"},{"location":"transitions/","title":"Transitions","text":"<p>Transitions allow you to animate setting the result of an image request on a <code>Target</code>.</p> <p>Both <code>ImageLoader</code> and <code>ImageRequest</code> builders accept a <code>Transition.Factory</code>. Transitions allow you to control how the success/error drawable is set on the <code>Target</code>. This allows you to animate the target's view or wrap the input drawable.</p> <p>By default, Coil comes packaged with 2 transitions:</p> <ul> <li><code>CrossfadeTransition.Factory</code> which crossfades from the current drawable to the success/error drawable.</li> <li><code>Transition.Factory.NONE</code> which sets the drawable on the <code>Target</code> immediately without animating.</li> </ul> <p>Take a look at the <code>CrossfadeTransition</code> source code for an example of how to write a custom <code>Transition</code>.</p> <p>See the API documentation for more information.</p>"},{"location":"upgrading/","title":"Upgrading from Coil 1.x to 2.x","text":"<p>This is a short guide to highlight the main changes when upgrading from Coil 1.x to 2.x and how to handle them. This upgrade guide doesn't cover every binary or source incompatible change, but it does cover the most important changes.</p>"},{"location":"upgrading/#minimum-api-21","title":"Minimum API 21","text":"<p>Coil 2.x requires minimum API 21. This is also the minimum API required for Jetpack Compose and OkHttp 4.x.</p>"},{"location":"upgrading/#imagerequest-default-scale","title":"ImageRequest default scale","text":"<p>Coil 2.x changes <code>ImageRequest</code>'s default scale from <code>Scale.FILL</code> to <code>Scale.FIT</code>. This was done to be consistent with <code>ImageView</code>'s default <code>ScaleType</code> and <code>Image</code>'s default <code>ContentScale</code>. Scale is still autodetected if you set an <code>ImageView</code> as your <code>ImageRequest.target</code>.</p>"},{"location":"upgrading/#size-refactor","title":"Size refactor","text":"<p><code>Size</code>'s <code>width</code> and <code>height</code> are now two <code>Dimension</code>s instead of <code>Int</code> pixel values. <code>Dimension</code> is either a pixel value or <code>Dimension.Undefined</code>, which represents an undefined/unbounded constraint. For example, if the size is <code>Size(400, Dimension.Undefined)</code> that means the image should be scaled to have 400 pixels for its width irrespective of its height. You can use the <code>pxOrElse</code> extension to get the pixel value (if present), else use a fallback:</p> <pre><code>val width = size.width.pxOrElse { -1 }\nif (width &gt; 0) {\n// Use the pixel value.\n}\n</code></pre> <p>This change was made to improve support for cases where a target has one unbounded dimension (e.g. if one dimension is <code>ViewGroup.LayoutParams.WRAP_CONTENT</code> for a <code>View</code> or <code>Constraints.Infinity</code> in Compose).</p>"},{"location":"upgrading/#jetpack-compose","title":"Jetpack Compose","text":"<p>Coil 2.x significantly reworks the Jetpack Compose integration to add features, improve stability, and improve performance.</p> <p>In Coil 1.x you would use <code>rememberImagePainter</code> to load an image:</p> <pre><code>val painter = rememberImagePainter(\"https://www.example.com/image.jpg\") {\ncrossfade(true)\n}\nImage(\npainter = painter,\ncontentDescription = null,\ncontentScale = ContentScale.Crop\n)\n</code></pre> <p>In Coil 2.x <code>rememberImagePainter</code> has been changed to <code>rememberAsyncImagePainter</code> with the following changes:</p> <ul> <li>The trailing lambda argument to configure the <code>ImageRequest</code> has been removed.</li> <li>In Coil 2.x, <code>rememberAsyncImagePainter</code> defaults to using <code>ContentScale.Fit</code> to be consistent with <code>Image</code> whereas in Coil 1.x it would default to <code>ContentScale.Crop</code>. As such, if you set a custom <code>ContentScale</code> on <code>Image</code>, you now also need to pass it to <code>rememberAsyncImagePainter</code>.</li> </ul> <pre><code>val painter = rememberAsyncImagePainter(\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://www.example.com/image.jpg\")\n.crossfade(true)\n.build(),\ncontentScale = ContentScale.Crop\n)\nImage(\npainter = painter,\ncontentDescription = null,\ncontentScale = ContentScale.Crop\n)\n</code></pre> <p>Additionally, Coil now has <code>AsyncImage</code> and <code>SubcomposeAsyncImage</code> composable functions, which add new features and work-around some design limitations of <code>rememberAsyncImagePainter</code>. Check out the full Jetpack Compose docs here.</p>"},{"location":"upgrading/#disk-cache","title":"Disk Cache","text":"<p>Coil 2.x has its own public disk cache class that can be accessed using <code>imageLoader.diskCache</code>. Coil 1.x relied on OkHttp's disk cache, however it's no longer needed.</p> <p>To configure the disk cache in 1.x you would use <code>CoilUtils.createDefaultCache</code>:</p> <pre><code>ImageLoader.Builder(context)\n.okHttpClient {\nOkHttpClient.Builder().cache(CoilUtils.createDefaultCache(context)).build()\n}\n.build()\n</code></pre> <p>In Coil 2.x you should not set a <code>Cache</code> object on your <code>OkHttpClient</code> when used with an <code>ImageLoader</code>. Instead configure the disk cache object like so:</p> <pre><code>ImageLoader.Builder(context)\n.diskCache {\nDiskCache.Builder()\n.directory(context.cacheDir.resolve(\"image_cache\"))\n.build()\n}\n.build()\n</code></pre> <p>This change was made to add functionality and improve performance:</p> <ul> <li>Support thread interruption while decoding images.</li> <li>Thread interruption allows fast cancellation of decode operations. This is particularly important for quickly scrolling through a list.</li> <li>By using a custom disk cache Coil is able to ensure a network source is fully read to disk before decoding. This is necessary as writing the data to disk cannot be interrupted - only the decode step can be interrupted. OkHttp's <code>Cache</code> shouldn't be used with Coil 2.0 as it's not possible to guarantee that all data is written to disk before decoding.</li> <li>Avoid buffering/creating temporary files for decode APIs that don't support <code>InputStream</code>s or require direct access to a <code>File</code> (e.g. <code>ImageDecoder</code>, <code>MediaMetadataRetriever</code>).</li> <li>Add a public read/write <code>DiskCache</code> API.</li> </ul> <p>In Coil 2.x <code>Cache-Control</code> and other cache headers are still supported - except <code>Vary</code> headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached.</p> <p>When upgrading from Coil 1.x to 2.x, any existing disk cache will be cleared as the internal format has changed.</p>"},{"location":"upgrading/#image-pipeline-refactor","title":"Image pipeline refactor","text":"<p>Coil 2.x refactors the image pipeline classes to be more flexible. Here's a high-level list of the changes:</p> <ul> <li>Introduce a new class, <code>Keyer</code>, that computes the memory cache key for a request. It replaces <code>Fetcher.key</code>.</li> <li><code>Mapper</code>, <code>Keyer</code>, <code>Fetcher</code>, and <code>Decoder</code> can return <code>null</code> to delegate to the next element in the list of components.</li> <li>Add <code>Options</code> to <code>Mapper.map</code>'s signature.</li> <li>Introduce <code>Fetcher.Factory</code> and <code>Decoder.Factory</code>. Use the factories to determine if a specific <code>Fetcher</code>/<code>Decoder</code> is applicable. Return <code>null</code> if that <code>Fetcher</code>/<code>Decoder</code> is not applicable.</li> </ul>"},{"location":"upgrading/#remove-bitmap-pooling","title":"Remove bitmap pooling","text":"<p>Coil 2.x removes bitmap pooling and its associated classes (<code>BitmapPool</code>, <code>PoolableViewTarget</code>). See here for why it was removed.</p>"}]}
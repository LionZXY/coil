{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"code_of_conduct/","text":"Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"faq/","text":"FAQ \u00b6 Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search Github discussions . Can Coil be used with Java projects or mixed Kotlin/Java projects? \u00b6 Yes! Read here . How do I preload an image? \u00b6 Read here . How do I enable logging? \u00b6 Set logger(DebugLogger()) when constructing your ImageLoader . Note DebugLogger should only be used in debug builds. How do I target Java 8? \u00b6 Coil requires Java 8 bytecode . This is enabled by default on the Android Gradle Plugin 4.2.0 and later and the Kotlin Gradle Plugin 1.5.0 and later. If you're using older versions of those plugins add the following to your Gradle build script: Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } How do I get development snapshots? \u00b6 Add the snapshots repository to your list of repositories: Gradle ( .gradle ): allprojects { repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } } Gradle Kotlin DSL ( .gradle.kts ): allprojects { repositories { maven ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Then depend on the same artifacts with the latest snapshot version . Note Snapshots are deployed for each new commit on main that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.","title":"FAQ"},{"location":"faq/#faq","text":"Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search Github discussions .","title":"FAQ"},{"location":"faq/#can-coil-be-used-with-java-projects-or-mixed-kotlinjava-projects","text":"Yes! Read here .","title":"Can Coil be used with Java projects or mixed Kotlin/Java projects?"},{"location":"faq/#how-do-i-preload-an-image","text":"Read here .","title":"How do I preload an image?"},{"location":"faq/#how-do-i-enable-logging","text":"Set logger(DebugLogger()) when constructing your ImageLoader . Note DebugLogger should only be used in debug builds.","title":"How do I enable logging?"},{"location":"faq/#how-do-i-target-java-8","text":"Coil requires Java 8 bytecode . This is enabled by default on the Android Gradle Plugin 4.2.0 and later and the Kotlin Gradle Plugin 1.5.0 and later. If you're using older versions of those plugins add the following to your Gradle build script: Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } }","title":"How do I target Java 8?"},{"location":"faq/#how-do-i-get-development-snapshots","text":"Add the snapshots repository to your list of repositories: Gradle ( .gradle ): allprojects { repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } } Gradle Kotlin DSL ( .gradle.kts ): allprojects { repositories { maven ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Then depend on the same artifacts with the latest snapshot version . Note Snapshots are deployed for each new commit on main that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.","title":"How do I get development snapshots?"},{"location":"getting_started/","text":"Getting Started \u00b6 Artifacts \u00b6 Coil has 8 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact which depends on io.coil-kt:coil-base , creates a singleton ImageLoader , and includes the ImageView extension functions. io.coil-kt:coil-base : A subset of io.coil-kt:coil which does not include the singleton ImageLoader and the ImageView extension functions. io.coil-kt:coil-compose : Includes support for Jetpack Compose . io.coil-kt:coil-compose-base : A subset of io.coil-kt:coil-compose which does not include functions that depend on the singleton ImageLoader . io.coil-kt:coil-gif : Includes two decoders to support decoding GIFs. See GIFs for more details. io.coil-kt:coil-svg : Includes a decoder to support decoding SVGs. See SVGs for more details. io.coil-kt:coil-video : Includes a decoder to support decoding frames from any of Android's supported video formats . See videos for more details. io.coil-kt:coil-bom : Includes a bill of materials . Importing coil-bom allows you to depend on other Coil artifacts without specifying a version. Image Loaders \u00b6 ImageLoader s are service classes that execute ImageRequest s. ImageLoader s handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. The default Coil artifact ( io.coil-kt:coil ) includes the singleton ImageLoader , which can be accessed using an extension function: context.imageLoader . The singleton ImageLoader can be configured by implementing ImageLoaderFactory on your Application class: class MyApplication : Application (), ImageLoaderFactory { override fun newImageLoader (): ImageLoader { return ImageLoader . Builder ( this ) . crossfade ( true ) . build () } } Implementing ImageLoaderFactory is optional. If you don't, Coil will lazily create an ImageLoader with the default values. Check out the full documentation for more info. Image Requests \u00b6 ImageRequest s are value classes that are executed by ImageLoader s. They describe where an image should be loaded from, how it should be loaded, and any extra parameters. An ImageLoader has two methods that can execute a request: enqueue : Enqueues the ImageRequest to be executed asynchronously on a background thread. execute : Executes the ImageRequest in the current coroutine and returns an ImageResult . All requests should set data (i.e. url, uri, file, drawable resource, etc.). This is what the ImageLoader will use to decide where to fetch the image data from. If you do not set data , it will default to NullRequestData . Additionally, you likely want to set a target when enqueuing a request. It's optional, but the target is what will receive the loaded placeholder/success/error drawables. Executed requests return an ImageResult which has the success/error drawable. Here's an example: // enqueue val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . enqueue ( request ) // execute val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request ) ImageView Extension Functions \u00b6 The io.coil-kt:coil artifact provides a set of ImageView extension functions. Here's an example for loading a URL into an ImageView : imageView . load ( \"https://www.example.com/image.jpg\" ) The above call is equivalent to: val imageLoader = imageView . context . imageLoader val request = ImageRequest . Builder ( imageView . context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () imageLoader . enqueue ( request ) ImageView.load calls can be configured with an optional trailing lambda parameter: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here for more information. Supported Data Types \u00b6 The base data types that are supported by all ImageLoader instances are: String (mapped to a Uri) HttpUrl Uri ( android.resource , content , file , http , and https schemes) File @DrawableRes Int Drawable Bitmap ByteArray ByteBuffer Supported Image Formats \u00b6 All ImageLoader s support the following non-animated file types: BMP JPEG PNG WebP HEIF (Android 8.0+) Additionally, Coil has extension libraries for the following file types: coil-gif : GIF, animated WebP (Android 9.0+), animated HEIF (Android 11.0+) coil-svg : SVG coil-video : Static video frames from any video codec supported by Android Preloading \u00b6 To preload an image into memory, enqueue or execute an ImageRequest without a Target : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) // Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at. . size ( ViewSizeResolver ( imageView )) . build () imageLoader . enqueue ( request ) To preload a network image only into the disk cache, disable the memory cache for the request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . memoryCachePolicy ( CachePolicy . DISABLED ) . build () imageLoader . enqueue ( request ) Cancelling Requests \u00b6 ImageRequest s will be automatically cancelled in the following cases: request.lifecycle reaches the DESTROYED state. request.target is a ViewTarget and its View is detached. Additionally, ImageLoader.enqueue returns a Disposable , which can be used to dispose the request (which cancels it and frees its associated resources): val disposable = imageView . load ( \"https://www.example.com/image.jpg\" ) // Cancel the request. disposable . dispose ()","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#artifacts","text":"Coil has 8 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact which depends on io.coil-kt:coil-base , creates a singleton ImageLoader , and includes the ImageView extension functions. io.coil-kt:coil-base : A subset of io.coil-kt:coil which does not include the singleton ImageLoader and the ImageView extension functions. io.coil-kt:coil-compose : Includes support for Jetpack Compose . io.coil-kt:coil-compose-base : A subset of io.coil-kt:coil-compose which does not include functions that depend on the singleton ImageLoader . io.coil-kt:coil-gif : Includes two decoders to support decoding GIFs. See GIFs for more details. io.coil-kt:coil-svg : Includes a decoder to support decoding SVGs. See SVGs for more details. io.coil-kt:coil-video : Includes a decoder to support decoding frames from any of Android's supported video formats . See videos for more details. io.coil-kt:coil-bom : Includes a bill of materials . Importing coil-bom allows you to depend on other Coil artifacts without specifying a version.","title":"Artifacts"},{"location":"getting_started/#image-loaders","text":"ImageLoader s are service classes that execute ImageRequest s. ImageLoader s handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. The default Coil artifact ( io.coil-kt:coil ) includes the singleton ImageLoader , which can be accessed using an extension function: context.imageLoader . The singleton ImageLoader can be configured by implementing ImageLoaderFactory on your Application class: class MyApplication : Application (), ImageLoaderFactory { override fun newImageLoader (): ImageLoader { return ImageLoader . Builder ( this ) . crossfade ( true ) . build () } } Implementing ImageLoaderFactory is optional. If you don't, Coil will lazily create an ImageLoader with the default values. Check out the full documentation for more info.","title":"Image Loaders"},{"location":"getting_started/#image-requests","text":"ImageRequest s are value classes that are executed by ImageLoader s. They describe where an image should be loaded from, how it should be loaded, and any extra parameters. An ImageLoader has two methods that can execute a request: enqueue : Enqueues the ImageRequest to be executed asynchronously on a background thread. execute : Executes the ImageRequest in the current coroutine and returns an ImageResult . All requests should set data (i.e. url, uri, file, drawable resource, etc.). This is what the ImageLoader will use to decide where to fetch the image data from. If you do not set data , it will default to NullRequestData . Additionally, you likely want to set a target when enqueuing a request. It's optional, but the target is what will receive the loaded placeholder/success/error drawables. Executed requests return an ImageResult which has the success/error drawable. Here's an example: // enqueue val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . enqueue ( request ) // execute val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request )","title":"Image Requests"},{"location":"getting_started/#imageview-extension-functions","text":"The io.coil-kt:coil artifact provides a set of ImageView extension functions. Here's an example for loading a URL into an ImageView : imageView . load ( \"https://www.example.com/image.jpg\" ) The above call is equivalent to: val imageLoader = imageView . context . imageLoader val request = ImageRequest . Builder ( imageView . context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () imageLoader . enqueue ( request ) ImageView.load calls can be configured with an optional trailing lambda parameter: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here for more information.","title":"ImageView Extension Functions"},{"location":"getting_started/#supported-data-types","text":"The base data types that are supported by all ImageLoader instances are: String (mapped to a Uri) HttpUrl Uri ( android.resource , content , file , http , and https schemes) File @DrawableRes Int Drawable Bitmap ByteArray ByteBuffer","title":"Supported Data Types"},{"location":"getting_started/#supported-image-formats","text":"All ImageLoader s support the following non-animated file types: BMP JPEG PNG WebP HEIF (Android 8.0+) Additionally, Coil has extension libraries for the following file types: coil-gif : GIF, animated WebP (Android 9.0+), animated HEIF (Android 11.0+) coil-svg : SVG coil-video : Static video frames from any video codec supported by Android","title":"Supported Image Formats"},{"location":"getting_started/#preloading","text":"To preload an image into memory, enqueue or execute an ImageRequest without a Target : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) // Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at. . size ( ViewSizeResolver ( imageView )) . build () imageLoader . enqueue ( request ) To preload a network image only into the disk cache, disable the memory cache for the request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . memoryCachePolicy ( CachePolicy . DISABLED ) . build () imageLoader . enqueue ( request )","title":"Preloading"},{"location":"getting_started/#cancelling-requests","text":"ImageRequest s will be automatically cancelled in the following cases: request.lifecycle reaches the DESTROYED state. request.target is a ViewTarget and its View is detached. Additionally, ImageLoader.enqueue returns a Disposable , which can be used to dispose the request (which cancels it and frees its associated resources): val disposable = imageView . load ( \"https://www.example.com/image.jpg\" ) // Cancel the request. disposable . dispose ()","title":"Cancelling Requests"},{"location":"image_loaders/","text":"Image Loaders \u00b6 ImageLoader s are service objects that execute ImageRequest s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, disk cache, and OkHttpClient . Caching \u00b6 Each ImageLoader keeps a memory cache of recently decoded Bitmap s as well as a disk cache for any images loaded from the Internet. Both can be configured when creating an ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . memoryCache { MemoryCache . Builder ( context ) . maxSizePercent ( 0.25 ) . build () } . diskCache { DiskCache . Builder ( context ) . directory ( context . cacheDir . resolve ( \"image_cache\" )) . maxSizePercent ( 0.02 ) . build () } . build () You can access items in the memory and disk caches using their keys, which are returned in an ImageResult after an image is loaded. The ImageResult is returned by ImageLoader.execute or in ImageRequest.Listener.onSuccess and ImageRequest.Listener.onError . Note Coil 1.x relied on OkHttp's disk cache. Coil 2.x has its own disk cache and should not use OkHttp's Cache . Singleton vs. Dependency Injection \u00b6 The default Coil artifact ( io.coil-kt:coil ) includes the singleton ImageLoader , which can be accessed using an extension function: context.imageLoader . Coil performs best when you have a single ImageLoader that's shared throughout your app. This is because each ImageLoader has its own set of resources. The singleton ImageLoader can be configured by implementing ImageLoaderFactory on your Application class. Optionally, you can create your own ImageLoader instance(s) and inject them using a dependency injector like Dagger . If you do that, depend on io.coil-kt:coil-base as that artifact doesn't create the singleton ImageLoader . Testing \u00b6 ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could create a fake ImageLoader implementation which always returns the same Drawable synchronously: class FakeImageLoader ( private val context : Context ) : ImageLoader { override val defaults = DefaultRequestOptions () override val components = ComponentRegistry () override val memoryCache : MemoryCache? get () = null override val diskCache : DiskCache? get () = null override fun enqueue ( request : ImageRequest ): Disposable { // Always call onStart before onSuccess. request . target ?. onStart ( request . placeholder ) val result = ColorDrawable ( Color . BLACK ) request . target ?. onSuccess ( result ) return object : Disposable { override val job = CompletableDeferred ( newResult ( request , result )) override val isDisposed get () = true override fun dispose () {} } } override suspend fun execute ( request : ImageRequest ): ImageResult { return newResult ( request , ColorDrawable ( Color . BLACK )) } private fun newResult ( request : ImageRequest , drawable : Drawable ): SuccessResult { return SuccessResult ( drawable = drawable , request = request , dataSource = DataSource . MEMORY_CACHE ) } override fun newBuilder () = throw UnsupportedOperationException () override fun shutdown () {} } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Image Loaders"},{"location":"image_loaders/#image-loaders","text":"ImageLoader s are service objects that execute ImageRequest s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, disk cache, and OkHttpClient .","title":"Image Loaders"},{"location":"image_loaders/#caching","text":"Each ImageLoader keeps a memory cache of recently decoded Bitmap s as well as a disk cache for any images loaded from the Internet. Both can be configured when creating an ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . memoryCache { MemoryCache . Builder ( context ) . maxSizePercent ( 0.25 ) . build () } . diskCache { DiskCache . Builder ( context ) . directory ( context . cacheDir . resolve ( \"image_cache\" )) . maxSizePercent ( 0.02 ) . build () } . build () You can access items in the memory and disk caches using their keys, which are returned in an ImageResult after an image is loaded. The ImageResult is returned by ImageLoader.execute or in ImageRequest.Listener.onSuccess and ImageRequest.Listener.onError . Note Coil 1.x relied on OkHttp's disk cache. Coil 2.x has its own disk cache and should not use OkHttp's Cache .","title":"Caching"},{"location":"image_loaders/#singleton-vs-dependency-injection","text":"The default Coil artifact ( io.coil-kt:coil ) includes the singleton ImageLoader , which can be accessed using an extension function: context.imageLoader . Coil performs best when you have a single ImageLoader that's shared throughout your app. This is because each ImageLoader has its own set of resources. The singleton ImageLoader can be configured by implementing ImageLoaderFactory on your Application class. Optionally, you can create your own ImageLoader instance(s) and inject them using a dependency injector like Dagger . If you do that, depend on io.coil-kt:coil-base as that artifact doesn't create the singleton ImageLoader .","title":"Singleton vs. Dependency Injection"},{"location":"image_loaders/#testing","text":"ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could create a fake ImageLoader implementation which always returns the same Drawable synchronously: class FakeImageLoader ( private val context : Context ) : ImageLoader { override val defaults = DefaultRequestOptions () override val components = ComponentRegistry () override val memoryCache : MemoryCache? get () = null override val diskCache : DiskCache? get () = null override fun enqueue ( request : ImageRequest ): Disposable { // Always call onStart before onSuccess. request . target ?. onStart ( request . placeholder ) val result = ColorDrawable ( Color . BLACK ) request . target ?. onSuccess ( result ) return object : Disposable { override val job = CompletableDeferred ( newResult ( request , result )) override val isDisposed get () = true override fun dispose () {} } } override suspend fun execute ( request : ImageRequest ): ImageResult { return newResult ( request , ColorDrawable ( Color . BLACK )) } private fun newResult ( request : ImageRequest , drawable : Drawable ): SuccessResult { return SuccessResult ( drawable = drawable , request = request , dataSource = DataSource . MEMORY_CACHE ) } override fun newBuilder () = throw UnsupportedOperationException () override fun shutdown () {} } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Testing"},{"location":"image_pipeline/","text":"Extending the Image Pipeline \u00b6 Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, MP4, etc.) Fortunately, ImageLoader s support pluggable components to add new cache layers, new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of five main parts that are executed in the following order: Interceptors , Mappers , Keyers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader . Builder ( context ) . components { add ( CustomCacheInterceptor ()) add ( ItemMapper ()) add ( HttpUrlKeyer ()) add ( CronetFetcher . Factory ()) add ( GifDecoder . Factory ()) } . build () Interceptors \u00b6 Interceptors allow you to observe, transform, short circuit, or retry requests to an ImageLoader 's image engine. For example, you can add a custom cache layer like so: class CustomCacheInterceptor ( private val context : Context , private val cache : LruCache < String , Drawable > ) : Interceptor { override suspend fun intercept ( chain : Interceptor . Chain ): ImageResult { val value = cache . get ( chain . request . data . toString ()) if ( value != null ) { return SuccessResult ( drawable = value . bitmap . toDrawable ( context ), request = chain . request , dataSource = DataSource . MEMORY_CACHE ) } return chain . proceed ( chain . request ) } } Interceptors are an advanced feature that let you wrap an ImageLoader 's image pipeline with custom logic. Their design is heavily based on OkHttp's Interceptor interface . See Interceptor for more information. Mappers \u00b6 Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to its URL, which will be handled later in the pipeline: class ItemMapper : Mapper < Item , String > { override fun map ( data : Item , options : Options ) = data . imageUrl } After registering it when building our ImageLoader (see above), we can safely load an Item : val request = ImageRequest . Builder ( context ) . data ( item ) . target ( imageView ) . build () imageLoader . enqueue ( request ) See Mapper for more information. Keyers \u00b6 Keyers convert data into a portion of a cache key. This value is used as MemoryCache.Key.key when/if this request's output is written to the MemoryCache . See Keyers for more information. Fetchers \u00b6 Fetchers translate data (e.g. URL, URI, File, etc.) into either an ImageSource or a Drawable . They typically convert the input data into a format that can then be consumed by a Decoder . Use this interface to add support for custom fetching mechanisms (e.g. Cronet, custom URI schemes, etc.) See Fetcher for more information. Decoders \u00b6 Decoders read an ImageSource and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information.","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#extending-the-image-pipeline","text":"Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, MP4, etc.) Fortunately, ImageLoader s support pluggable components to add new cache layers, new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of five main parts that are executed in the following order: Interceptors , Mappers , Keyers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader . Builder ( context ) . components { add ( CustomCacheInterceptor ()) add ( ItemMapper ()) add ( HttpUrlKeyer ()) add ( CronetFetcher . Factory ()) add ( GifDecoder . Factory ()) } . build ()","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#interceptors","text":"Interceptors allow you to observe, transform, short circuit, or retry requests to an ImageLoader 's image engine. For example, you can add a custom cache layer like so: class CustomCacheInterceptor ( private val context : Context , private val cache : LruCache < String , Drawable > ) : Interceptor { override suspend fun intercept ( chain : Interceptor . Chain ): ImageResult { val value = cache . get ( chain . request . data . toString ()) if ( value != null ) { return SuccessResult ( drawable = value . bitmap . toDrawable ( context ), request = chain . request , dataSource = DataSource . MEMORY_CACHE ) } return chain . proceed ( chain . request ) } } Interceptors are an advanced feature that let you wrap an ImageLoader 's image pipeline with custom logic. Their design is heavily based on OkHttp's Interceptor interface . See Interceptor for more information.","title":"Interceptors"},{"location":"image_pipeline/#mappers","text":"Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to its URL, which will be handled later in the pipeline: class ItemMapper : Mapper < Item , String > { override fun map ( data : Item , options : Options ) = data . imageUrl } After registering it when building our ImageLoader (see above), we can safely load an Item : val request = ImageRequest . Builder ( context ) . data ( item ) . target ( imageView ) . build () imageLoader . enqueue ( request ) See Mapper for more information.","title":"Mappers"},{"location":"image_pipeline/#keyers","text":"Keyers convert data into a portion of a cache key. This value is used as MemoryCache.Key.key when/if this request's output is written to the MemoryCache . See Keyers for more information.","title":"Keyers"},{"location":"image_pipeline/#fetchers","text":"Fetchers translate data (e.g. URL, URI, File, etc.) into either an ImageSource or a Drawable . They typically convert the input data into a format that can then be consumed by a Decoder . Use this interface to add support for custom fetching mechanisms (e.g. Cronet, custom URI schemes, etc.) See Fetcher for more information.","title":"Fetchers"},{"location":"image_pipeline/#decoders","text":"Decoders read an ImageSource and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information.","title":"Decoders"},{"location":"image_requests/","text":"Image Requests \u00b6 ImageRequest s are value objects that provide all the necessary information for an ImageLoader to load an image. ImageRequest s can be created using a builder: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build () Once you've created a request pass it to an ImageLoader to enqueue/execute it: imageLoader . enqueue ( request ) See the API documentation for more information.","title":"Image Requests"},{"location":"image_requests/#image-requests","text":"ImageRequest s are value objects that provide all the necessary information for an ImageLoader to load an image. ImageRequest s can be created using a builder: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build () Once you've created a request pass it to an ImageLoader to enqueue/execute it: imageLoader . enqueue ( request ) See the API documentation for more information.","title":"Image Requests"},{"location":"java_compatibility/","text":"Java Compatibility \u00b6 Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Importantly, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. Despite these limitations, most of Coil's API is Java compatible. The Context.imageLoader extension function should not be used from Java. Instead, you can get the singleton ImageLoader using: ImageLoader imageLoader = Coil . imageLoader ( context ) The syntax to enqueue an ImageRequest is almost the same in Java and Kotlin: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . enqueue ( request ) Note ImageView.load cannot be used from Java. Use the ImageRequest.Builder API instead. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to use the ImageLoader.executeBlocking extension function which can be called from Java like so: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaders . executeBlocking ( imageLoader , request ). getDrawable (); Note ImageLoaders.executeBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"java_compatibility/#java-compatibility","text":"Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Importantly, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. Despite these limitations, most of Coil's API is Java compatible. The Context.imageLoader extension function should not be used from Java. Instead, you can get the singleton ImageLoader using: ImageLoader imageLoader = Coil . imageLoader ( context ) The syntax to enqueue an ImageRequest is almost the same in Java and Kotlin: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . enqueue ( request ) Note ImageView.load cannot be used from Java. Use the ImageRequest.Builder API instead. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to use the ImageLoader.executeBlocking extension function which can be called from Java like so: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaders . executeBlocking ( imageLoader , request ). getDrawable (); Note ImageLoaders.executeBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"migrating/","text":"Migrating from Glide/Picasso \u00b6 Here are a few examples of how to migrate Glide/Picasso calls into Coil calls: Basic Usage \u00b6 // Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url ) Custom Requests \u00b6 imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (automatically detects the scale type) imageView . load ( url ) { placeholder ( placeholder ) } Non-View Targets \u00b6 // Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget < Drawable > () { override fun onResourceReady ( resource : Drawable , transition : Transition < Drawable > ) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable?) { // Handle the placeholder drawable. } }) // Coil val request = ImageRequest . Builder ( context ) . data ( url ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () context . imageLoader . enqueue ( request ) Background Thread \u00b6 // Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current coroutine; non-blocking and thread safe) val request = ImageRequest . Builder ( context ) . data ( url ) . size ( width , height ) . build () val drawable = context . imageLoader . execute ( request ). drawable","title":"Migrating from Glide/Picasso"},{"location":"migrating/#migrating-from-glidepicasso","text":"Here are a few examples of how to migrate Glide/Picasso calls into Coil calls:","title":"Migrating from Glide/Picasso"},{"location":"migrating/#basic-usage","text":"// Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url )","title":"Basic Usage"},{"location":"migrating/#custom-requests","text":"imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (automatically detects the scale type) imageView . load ( url ) { placeholder ( placeholder ) }","title":"Custom Requests"},{"location":"migrating/#non-view-targets","text":"// Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget < Drawable > () { override fun onResourceReady ( resource : Drawable , transition : Transition < Drawable > ) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable?) { // Handle the placeholder drawable. } }) // Coil val request = ImageRequest . Builder ( context ) . data ( url ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () context . imageLoader . enqueue ( request )","title":"Non-View Targets"},{"location":"migrating/#background-thread","text":"// Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current coroutine; non-blocking and thread safe) val request = ImageRequest . Builder ( context ) . data ( url ) . size ( width , height ) . build () val drawable = context . imageLoader . execute ( request ). drawable","title":"Background Thread"},{"location":"recipes/","text":"Recipes \u00b6 This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fit your exact requirements, but it should hopefully give you a push in the right direction! See a common use case that isn't covered? Feel free to submit a PR with a new section. Palette \u00b6 Palette allows you to extract prominent colors from an image. To create a Palette , you'll need access to an image's Bitmap . This can be done in a number of ways: You can get access to an image's bitmap by setting a ImageRequest.Listener and enqueuing an ImageRequest : imageView . load ( \"https://www.example.com/image.jpg\" ) { // Disable hardware bitmaps as Palette needs to read the image's pixels. allowHardware ( false ) listener ( onSuccess = { _ , result -> // Create the palette on a background thread. Palette . Builder ( result . drawable . toBitmap ()). generate { palette -> // Consume the palette. } } ) } Using a custom OkHttpClient \u00b6 Coil uses OkHttp for all its networking operations. You can specify a custom OkHttpClient when creating your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) // Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread. . okHttpClient { OkHttpClient . Builder () . addInterceptor ( CustomInterceptor ()) . build () } . build () Note If you already have a built OkHttpClient , use newBuilder() to build a new client that shares resources with the original. Headers \u00b6 Headers can be added to your image requests in one of two ways. You can set headers for a single request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . setHeader ( \"Cache-Control\" , \"no-cache\" ) . target ( imageView ) . build () imageLoader . execute ( request ) Or you can create an OkHttp Interceptor that sets headers for every request executed by your ImageLoader : class RequestHeaderInterceptor ( private val name : String , private val value : String ) : Interceptor { override fun intercept ( chain : Interceptor . Chain ): Response { val request = chain . request (). newBuilder () . header ( name , value ) . build () return chain . proceed ( request ) } } val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () // This header will be added to every image request. . addNetworkInterceptor ( RequestHeaderInterceptor ( \"Cache-Control\" , \"no-cache\" )) . build () } . build () Using a Memory Cache Key as a Placeholder \u00b6 Using a previous request's MemoryCache.Key as a placeholder for a subsequent request can be useful if the two images are the same, though loaded at different sizes. For instance, if the first request loads the image at 100x100 and the second request loads the image at 500x500, we can use the first image as a synchronous placeholder for the second request. Here's what this effect looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect. To achieve this effect, use the MemoryCache.Key of the first request as the ImageRequest.placeholderMemoryCacheKey of the second request. Here's an example: // First request listImageView . load ( \"https://www.example.com/image.jpg\" ) // Second request (once the first request finishes) detailImageView . load ( \"https://www.example.com/image.jpg\" ) { placeholderMemoryCacheKey ( listImageView . result . memoryCacheKey ) } Note Previous versions of Coil would attempt to set up this effect automatically . This required executing parts of the image pipeline synchronously on the main thread and it was ultimately removed in version 0.12.0 . Shared Element Transitions \u00b6 Shared element transitions allow you to animate between Activities and Fragments . Here are some recommendations on how to get them to work with Coil: Shared element transitions are incompatible with hardware bitmaps. You should set allowHardware(false) to disable hardware bitmaps for both the ImageView you are animating from and the view you are animating to. If you don't, the transition will throw an java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps exception. Use the MemoryCache.Key of the start image as the placeholderMemoryCacheKey for the end image. This ensures that the start image is used as the placeholder for the end image, which results in a smooth transition with no white flashes if the image is in the memory cache. Use ChangeImageTransform and ChangeBounds together for optimal results. Remote Views \u00b6 Coil does not provide a Target for RemoteViews out of the box, however you can create one like so: class RemoteViewsTarget ( private val context : Context , private val componentName : ComponentName , private val remoteViews : RemoteViews , @IdRes private val imageViewResId : Int ) : Target { override fun onStart ( placeholder : Drawable?) = setDrawable ( placeholder ) override fun onError ( error : Drawable?) = setDrawable ( error ) override fun onSuccess ( result : Drawable ) = setDrawable ( result ) private fun setDrawable ( drawable : Drawable?) { remoteViews . setImageViewBitmap ( imageViewResId , drawable ?. toBitmap ()) AppWidgetManager . getInstance ( context ). updateAppWidget ( componentName , remoteViews ) } } Then enqueue / execute the request like normal: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( RemoteViewsTarget ( context , componentName , remoteViews , imageViewResId )) . build () imageLoader . enqueue ( request ) Transforming Painters \u00b6 Both AsyncImage and AsyncImagePainter have placeholder / error / fallback arguments that accept Painter s. Painters are less flexible than using composables, but are faster as Coil doesn't need to use subcomposition. That said, it may be necessary to inset, stretch, tint, or transform your painter to get the desired UI. To accomplish this, copy this Gist into your project and wrap the painter like so: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null , placeholder = forwardingPainter ( painter = painterResource ( R . drawable . placeholder ), colorFilter = ColorFilter ( Color . Red ), alpha = 0.5f ) ) The onDraw can be overwritten using a trailing lambda: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null , placeholder = forwardingPainter ( painterResource ( R . drawable . placeholder )) { info -> inset ( 50f , 50f ) { with ( info . painter ) { draw ( size , info . alpha , info . colorFilter ) } } } )","title":"Recipes"},{"location":"recipes/#recipes","text":"This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fit your exact requirements, but it should hopefully give you a push in the right direction! See a common use case that isn't covered? Feel free to submit a PR with a new section.","title":"Recipes"},{"location":"recipes/#palette","text":"Palette allows you to extract prominent colors from an image. To create a Palette , you'll need access to an image's Bitmap . This can be done in a number of ways: You can get access to an image's bitmap by setting a ImageRequest.Listener and enqueuing an ImageRequest : imageView . load ( \"https://www.example.com/image.jpg\" ) { // Disable hardware bitmaps as Palette needs to read the image's pixels. allowHardware ( false ) listener ( onSuccess = { _ , result -> // Create the palette on a background thread. Palette . Builder ( result . drawable . toBitmap ()). generate { palette -> // Consume the palette. } } ) }","title":"Palette"},{"location":"recipes/#using-a-custom-okhttpclient","text":"Coil uses OkHttp for all its networking operations. You can specify a custom OkHttpClient when creating your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) // Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread. . okHttpClient { OkHttpClient . Builder () . addInterceptor ( CustomInterceptor ()) . build () } . build () Note If you already have a built OkHttpClient , use newBuilder() to build a new client that shares resources with the original.","title":"Using a custom OkHttpClient"},{"location":"recipes/#headers","text":"Headers can be added to your image requests in one of two ways. You can set headers for a single request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . setHeader ( \"Cache-Control\" , \"no-cache\" ) . target ( imageView ) . build () imageLoader . execute ( request ) Or you can create an OkHttp Interceptor that sets headers for every request executed by your ImageLoader : class RequestHeaderInterceptor ( private val name : String , private val value : String ) : Interceptor { override fun intercept ( chain : Interceptor . Chain ): Response { val request = chain . request (). newBuilder () . header ( name , value ) . build () return chain . proceed ( request ) } } val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () // This header will be added to every image request. . addNetworkInterceptor ( RequestHeaderInterceptor ( \"Cache-Control\" , \"no-cache\" )) . build () } . build ()","title":"Headers"},{"location":"recipes/#using-a-memory-cache-key-as-a-placeholder","text":"Using a previous request's MemoryCache.Key as a placeholder for a subsequent request can be useful if the two images are the same, though loaded at different sizes. For instance, if the first request loads the image at 100x100 and the second request loads the image at 500x500, we can use the first image as a synchronous placeholder for the second request. Here's what this effect looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect. To achieve this effect, use the MemoryCache.Key of the first request as the ImageRequest.placeholderMemoryCacheKey of the second request. Here's an example: // First request listImageView . load ( \"https://www.example.com/image.jpg\" ) // Second request (once the first request finishes) detailImageView . load ( \"https://www.example.com/image.jpg\" ) { placeholderMemoryCacheKey ( listImageView . result . memoryCacheKey ) } Note Previous versions of Coil would attempt to set up this effect automatically . This required executing parts of the image pipeline synchronously on the main thread and it was ultimately removed in version 0.12.0 .","title":"Using a Memory Cache Key as a Placeholder"},{"location":"recipes/#shared-element-transitions","text":"Shared element transitions allow you to animate between Activities and Fragments . Here are some recommendations on how to get them to work with Coil: Shared element transitions are incompatible with hardware bitmaps. You should set allowHardware(false) to disable hardware bitmaps for both the ImageView you are animating from and the view you are animating to. If you don't, the transition will throw an java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps exception. Use the MemoryCache.Key of the start image as the placeholderMemoryCacheKey for the end image. This ensures that the start image is used as the placeholder for the end image, which results in a smooth transition with no white flashes if the image is in the memory cache. Use ChangeImageTransform and ChangeBounds together for optimal results.","title":"Shared Element Transitions"},{"location":"recipes/#remote-views","text":"Coil does not provide a Target for RemoteViews out of the box, however you can create one like so: class RemoteViewsTarget ( private val context : Context , private val componentName : ComponentName , private val remoteViews : RemoteViews , @IdRes private val imageViewResId : Int ) : Target { override fun onStart ( placeholder : Drawable?) = setDrawable ( placeholder ) override fun onError ( error : Drawable?) = setDrawable ( error ) override fun onSuccess ( result : Drawable ) = setDrawable ( result ) private fun setDrawable ( drawable : Drawable?) { remoteViews . setImageViewBitmap ( imageViewResId , drawable ?. toBitmap ()) AppWidgetManager . getInstance ( context ). updateAppWidget ( componentName , remoteViews ) } } Then enqueue / execute the request like normal: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( RemoteViewsTarget ( context , componentName , remoteViews , imageViewResId )) . build () imageLoader . enqueue ( request )","title":"Remote Views"},{"location":"recipes/#transforming-painters","text":"Both AsyncImage and AsyncImagePainter have placeholder / error / fallback arguments that accept Painter s. Painters are less flexible than using composables, but are faster as Coil doesn't need to use subcomposition. That said, it may be necessary to inset, stretch, tint, or transform your painter to get the desired UI. To accomplish this, copy this Gist into your project and wrap the painter like so: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null , placeholder = forwardingPainter ( painter = painterResource ( R . drawable . placeholder ), colorFilter = ColorFilter ( Color . Red ), alpha = 0.5f ) ) The onDraw can be overwritten using a trailing lambda: AsyncImage ( model = \"https://example.com/image.jpg\" , contentDescription = null , placeholder = forwardingPainter ( painterResource ( R . drawable . placeholder )) { info -> inset ( 50f , 50f ) { with ( info . painter ) { draw ( size , info . alpha , info . colorFilter ) } } } )","title":"Transforming Painters"},{"location":"targets/","text":"Targets \u00b6 Targets receive the Drawable result of an ImageRequest . They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a View (e.g. ImageViewTarget ). Here's the easiest way to create a custom target: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . enqueue ( request ) There are 2 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle.","title":"Targets"},{"location":"targets/#targets","text":"Targets receive the Drawable result of an ImageRequest . They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a View (e.g. ImageViewTarget ). Here's the easiest way to create a custom target: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . enqueue ( request ) There are 2 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle.","title":"Targets"},{"location":"transformations/","text":"Transformations \u00b6 Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 2 transformations: circle crop and rounded corners . Transformations only modify the pixel data for static images. Adding a transformation to an ImageRequest that produces an animated image will convert it to a static image so the transformation can be applied. To transform the pixel data of each frame of an animated image, see AnimatedTransformation . See the API documentation for more information. Note If the Drawable returned by the image pipeline is not a BitmapDrawable , it will be converted to one. This will cause animated drawables to only draw the first frame of their animation. This behaviour can be disabled by setting ImageRequest.Builder.allowConversionToBitmap(false) .","title":"Transformations"},{"location":"transformations/#transformations","text":"Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 2 transformations: circle crop and rounded corners . Transformations only modify the pixel data for static images. Adding a transformation to an ImageRequest that produces an animated image will convert it to a static image so the transformation can be applied. To transform the pixel data of each frame of an animated image, see AnimatedTransformation . See the API documentation for more information. Note If the Drawable returned by the image pipeline is not a BitmapDrawable , it will be converted to one. This will cause animated drawables to only draw the first frame of their animation. This behaviour can be disabled by setting ImageRequest.Builder.allowConversionToBitmap(false) .","title":"Transformations"},{"location":"transitions/","text":"Transitions \u00b6 Transitions allow you to animate setting the result of an image request on a Target . Both ImageLoader and ImageRequest builders accept a Transition.Factory . Transitions allow you to control how the success/error drawable is set on the Target . This allows you to animate the target's view or wrap the input drawable. By default, Coil comes packaged with 2 transitions: CrossfadeTransition.Factory which crossfades from the current drawable to the success/error drawable. Transition.Factory.NONE which sets the drawable on the Target immediately without animating. Take a look at the CrossfadeTransition source code for an example of how to write a custom Transition . See the API documentation for more information.","title":"Transitions"},{"location":"transitions/#transitions","text":"Transitions allow you to animate setting the result of an image request on a Target . Both ImageLoader and ImageRequest builders accept a Transition.Factory . Transitions allow you to control how the success/error drawable is set on the Target . This allows you to animate the target's view or wrap the input drawable. By default, Coil comes packaged with 2 transitions: CrossfadeTransition.Factory which crossfades from the current drawable to the success/error drawable. Transition.Factory.NONE which sets the drawable on the Target immediately without animating. Take a look at the CrossfadeTransition source code for an example of how to write a custom Transition . See the API documentation for more information.","title":"Transitions"},{"location":"upgrading/","text":"Upgrading from Coil 1.x to 2.x \u00b6 This is a short guide to highlight the main changes when upgrading from Coil 1.x to 2.x and how to handle them. This upgrade guide doesn't cover every binary or source incompatible change, but it does cover the most important changes. Minimum API 21 \u00b6 Coil 2.x requires minimum API 21. This is also the minimum API required for Jetpack Compose and OkHttp 4.x. ImageRequest default scale \u00b6 Coil 2.x changes ImageRequest 's default scale from Scale.FILL to Scale.FIT . This was done to be consistent with ImageView 's default ScaleType and Image 's default ContentScale . Scale is still autodetected if you set an ImageView as your ImageRequest.target . Size refactor \u00b6 Size 's width and height are now two Dimension s instead of Int pixel values. Dimension is either a pixel value or Dimension.Undefined , which represents an undefined/unbounded constraint. For example, if the size is Size(400, Dimension.Undefined) that means the image should be scaled to have 400 pixels for its width irrespective of its height. You can use the pxOrElse extension to get the pixel value (if present), else use a fallback: val width = size . width . pxOrElse { - 1 } if ( width > 0 ) { // Use the pixel value. } This change was made to improve support for cases where a target has one unbounded dimension (e.g. if one dimension is ViewGroup.LayoutParams.WRAP_CONTENT for a View or Constraints.Infinity in Compose). Jetpack Compose \u00b6 Coil 2.x significantly reworks the Jetpack Compose integration to add features, improve stability, and improve performance. In Coil 1.x you would use rememberImagePainter to load an image: val painter = rememberImagePainter ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) } Image ( painter = painter , contentDescription = null , contentScale = ContentScale . Crop ) In Coil 2.x rememberImagePainter has been changed to rememberAsyncImagePainter with the following changes: The trailing lambda argument to configure the ImageRequest has been removed. In Coil 2.x, rememberAsyncImagePainter defaults to using ContentScale.Fit to be consistent with Image whereas in Coil 1.x it would default to ContentScale.Crop . As such, if you set a custom ContentScale on Image , you now also need to pass it to rememberAsyncImagePainter . val painter = rememberAsyncImagePainter ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . build (), contentScale = ContentScale . Crop ) Image ( painter = painter , contentDescription = null , contentScale = ContentScale . Crop ) Additionally, Coil now has AsyncImage and SubcomposeAsyncImage composable functions, which add new features and work-around some design limitations of rememberAsyncImagePainter . Check out the full Jetpack Compose docs here . Disk Cache \u00b6 Coil 2.x has its own public disk cache class that can be accessed using imageLoader.diskCache . Coil 1.x relied on OkHttp's disk cache, however it's no longer needed. To configure the disk cache in 1.x you would use CoilUtils.createDefaultCache : ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder (). cache ( CoilUtils . createDefaultCache ( context )). build () } . build () In Coil 2.x you should not set a Cache object on your OkHttpClient when used with an ImageLoader . Instead configure the disk cache object like so: ImageLoader . Builder ( context ) . diskCache { DiskCache . Builder () . directory ( context . cacheDir . resolve ( \"image_cache\" )) . build () } . build () This change was made to add functionality and improve performance: Support thread interruption while decoding images. Thread interruption allows fast cancellation of decode operations. This is particularly important for quickly scrolling through a list. By using a custom disk cache Coil is able to ensure a network source is fully read to disk before decoding. This is necessary as writing the data to disk cannot be interrupted - only the decode step can be interrupted. OkHttp's Cache shouldn't be used with Coil 2.0 as it's not possible to guarantee that all data is written to disk before decoding. Avoid buffering/creating temporary files for decode APIs that don't support InputStream s or require direct access to a File (e.g. ImageDecoder , MediaMetadataRetriever ). Add a public read/write DiskCache API. In Coil 2.x Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. When upgrading from Coil 1.x to 2.x, any existing disk cache will be cleared as the internal format has changed. Image pipeline refactor \u00b6 Coil 2.x refactors the image pipeline classes to be more flexible. Here's a high-level list of the changes: Introduce a new class, Keyer , that computes the memory cache key for a request. It replaces Fetcher.key . Mapper , Keyer , Fetcher , and Decoder can return null to delegate to the next element in the list of components. Add Options to Mapper.map 's signature. Introduce Fetcher.Factory and Decoder.Factory . Use the factories to determine if a specific Fetcher / Decoder is applicable. Return null if that Fetcher / Decoder is not applicable. Remove bitmap pooling \u00b6 Coil 2.x removes bitmap pooling and its associated classes ( BitmapPool , PoolableViewTarget ). See here for why it was removed.","title":"Upgrading from Coil 1.x to 2.x"},{"location":"upgrading/#upgrading-from-coil-1x-to-2x","text":"This is a short guide to highlight the main changes when upgrading from Coil 1.x to 2.x and how to handle them. This upgrade guide doesn't cover every binary or source incompatible change, but it does cover the most important changes.","title":"Upgrading from Coil 1.x to 2.x"},{"location":"upgrading/#minimum-api-21","text":"Coil 2.x requires minimum API 21. This is also the minimum API required for Jetpack Compose and OkHttp 4.x.","title":"Minimum API 21"},{"location":"upgrading/#imagerequest-default-scale","text":"Coil 2.x changes ImageRequest 's default scale from Scale.FILL to Scale.FIT . This was done to be consistent with ImageView 's default ScaleType and Image 's default ContentScale . Scale is still autodetected if you set an ImageView as your ImageRequest.target .","title":"ImageRequest default scale"},{"location":"upgrading/#size-refactor","text":"Size 's width and height are now two Dimension s instead of Int pixel values. Dimension is either a pixel value or Dimension.Undefined , which represents an undefined/unbounded constraint. For example, if the size is Size(400, Dimension.Undefined) that means the image should be scaled to have 400 pixels for its width irrespective of its height. You can use the pxOrElse extension to get the pixel value (if present), else use a fallback: val width = size . width . pxOrElse { - 1 } if ( width > 0 ) { // Use the pixel value. } This change was made to improve support for cases where a target has one unbounded dimension (e.g. if one dimension is ViewGroup.LayoutParams.WRAP_CONTENT for a View or Constraints.Infinity in Compose).","title":"Size refactor"},{"location":"upgrading/#jetpack-compose","text":"Coil 2.x significantly reworks the Jetpack Compose integration to add features, improve stability, and improve performance. In Coil 1.x you would use rememberImagePainter to load an image: val painter = rememberImagePainter ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) } Image ( painter = painter , contentDescription = null , contentScale = ContentScale . Crop ) In Coil 2.x rememberImagePainter has been changed to rememberAsyncImagePainter with the following changes: The trailing lambda argument to configure the ImageRequest has been removed. In Coil 2.x, rememberAsyncImagePainter defaults to using ContentScale.Fit to be consistent with Image whereas in Coil 1.x it would default to ContentScale.Crop . As such, if you set a custom ContentScale on Image , you now also need to pass it to rememberAsyncImagePainter . val painter = rememberAsyncImagePainter ( model = ImageRequest . Builder ( LocalContext . current ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . build (), contentScale = ContentScale . Crop ) Image ( painter = painter , contentDescription = null , contentScale = ContentScale . Crop ) Additionally, Coil now has AsyncImage and SubcomposeAsyncImage composable functions, which add new features and work-around some design limitations of rememberAsyncImagePainter . Check out the full Jetpack Compose docs here .","title":"Jetpack Compose"},{"location":"upgrading/#disk-cache","text":"Coil 2.x has its own public disk cache class that can be accessed using imageLoader.diskCache . Coil 1.x relied on OkHttp's disk cache, however it's no longer needed. To configure the disk cache in 1.x you would use CoilUtils.createDefaultCache : ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder (). cache ( CoilUtils . createDefaultCache ( context )). build () } . build () In Coil 2.x you should not set a Cache object on your OkHttpClient when used with an ImageLoader . Instead configure the disk cache object like so: ImageLoader . Builder ( context ) . diskCache { DiskCache . Builder () . directory ( context . cacheDir . resolve ( \"image_cache\" )) . build () } . build () This change was made to add functionality and improve performance: Support thread interruption while decoding images. Thread interruption allows fast cancellation of decode operations. This is particularly important for quickly scrolling through a list. By using a custom disk cache Coil is able to ensure a network source is fully read to disk before decoding. This is necessary as writing the data to disk cannot be interrupted - only the decode step can be interrupted. OkHttp's Cache shouldn't be used with Coil 2.0 as it's not possible to guarantee that all data is written to disk before decoding. Avoid buffering/creating temporary files for decode APIs that don't support InputStream s or require direct access to a File (e.g. ImageDecoder , MediaMetadataRetriever ). Add a public read/write DiskCache API. In Coil 2.x Cache-Control and other cache headers are still supported - except Vary headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached. When upgrading from Coil 1.x to 2.x, any existing disk cache will be cleared as the internal format has changed.","title":"Disk Cache"},{"location":"upgrading/#image-pipeline-refactor","text":"Coil 2.x refactors the image pipeline classes to be more flexible. Here's a high-level list of the changes: Introduce a new class, Keyer , that computes the memory cache key for a request. It replaces Fetcher.key . Mapper , Keyer , Fetcher , and Decoder can return null to delegate to the next element in the list of components. Add Options to Mapper.map 's signature. Introduce Fetcher.Factory and Decoder.Factory . Use the factories to determine if a specific Fetcher / Decoder is applicable. Return null if that Fetcher / Decoder is not applicable.","title":"Image pipeline refactor"},{"location":"upgrading/#remove-bitmap-pooling","text":"Coil 2.x removes bitmap pooling and its associated classes ( BitmapPool , PoolableViewTarget ). See here for why it was removed.","title":"Remove bitmap pooling"}]}